// Generated by CoffeeScript 1.4.0
(function() {
  var Connection, EventEmitter, Model, async, _, _bindDomain, _use,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  Model = require('./model');

  _ = require('underscore');

  async = require('async');

  _bindDomain = function(fn) {
    var d;
    if (d = process.domain) {
      return d.bind(fn);
    } else {
      return fn;
    }
  };

  Connection = (function(_super) {

    __extends(Connection, _super);

    function Connection(adapter_name, settings) {
      var _this = this;
      if (settings.is_default !== false) {
        Connection.defaultConnection = this;
      }
      this.connected = false;
      this.models = {};
      this._pending_associations = [];
      this._schema_changed = false;
      this._adapter = require(__dirname + '/adapters/' + adapter_name)(this);
      this._adapter.connect(settings, _bindDomain(function(error) {
        if (error) {
          _this._adapter = null;
          _this.emit('error', error);
          return;
        }
        _this.connected = true;
        return _this.emit('connected');
      }));
    }

    Connection.prototype.model = function(name, schema) {
      return Model.newModel(this, name, schema);
    };

    Connection.prototype._waitingForConnection = function(object, method, args) {
      if (this.connected) {
        return false;
      }
      this.once('connected', function() {
        return method.apply(object, args);
      });
      return true;
    };

    Connection.prototype._waitingForApplyingSchemas = function(object, method, args) {
      if (!this._applying_schemas && !this._schema_changed) {
        return false;
      }
      this.once('schemas_applied', function() {
        return method.apply(object, args);
      });
      if (!this._applying_schemas) {
        this.applySchemas();
      }
      return true;
    };

    Connection.prototype.applySchemas = function(callback) {
      var callAdapter,
        _this = this;
      if (!this._schema_changed) {
        return typeof callback === "function" ? callback(null) : void 0;
      }
      this._applyAssociations();
      if (!this._applying_schemas) {
        this._applying_schemas = true;
        callAdapter = function() {
          return async.forEach(Object.keys(_this.models), function(model, callback) {
            var modelClass;
            modelClass = _this.models[model];
            if (!modelClass._schema_changed) {
              return callback(null);
            }
            return _this._adapter.applySchema(model, function(error) {
              if (!error) {
                modelClass._schema_changed = false;
              }
              return callback(error);
            });
          }, _bindDomain(function(error) {
            _this._applying_schemas = false;
            _this._schema_changed = false;
            _this.emit('schemas_applied');
            return typeof callback === "function" ? callback(error) : void 0;
          }));
        };
        if (this._waitingForConnection(this, callAdapter, arguments)) {
          return;
        }
        return callAdapter();
      } else {
        return typeof callback === "function" ? callback(null) : void 0;
      }
    };

    Connection.prototype.log = function(model, type, data) {};

    return Connection;

  })(EventEmitter);

  _use = function(file) {
    var MixClass;
    MixClass = require("./connection/" + file);
    _.extend(Connection, MixClass);
    return _.extend(Connection.prototype, MixClass.prototype);
  };

  _use('association');

  _use('manipulate');

  Model._Connection = Connection;

  module.exports = Connection;

}).call(this);
