// Generated by CoffeeScript 1.3.3
(function() {
  var DBConnection, DBModel, EventEmitter, type, value, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  DBModel = require('./model');

  /*
  # Manages connection to a database
  */


  DBConnection = (function(_super) {

    __extends(DBConnection, _super);

    /*
      # Creates a connection
      # @param {String} adapater_name
      # @param {Object} settings adapter specific settings
      # @see MySQLAdapter::connect
      # @see MongoDBAdapter::connect
      # @see PostgreSQLAdapter::connect
      # @see SQLite3Adapter::connect
    */


    function DBConnection(adapter_name, settings) {
      var _this = this;
      this.connected = false;
      this.models = {};
      this._adapter = require(__dirname + '/adapters/' + adapter_name)(this);
      this._adapter.connect(settings, function(error) {
        if (error) {
          _this._adapter = null;
          _this.emit('error', error);
          return;
        }
        _this.connected = true;
        return _this.emit('connected');
      });
    }

    /*
      # Creates a model class
      # @param {String} name
      # @param {Object} schema
      # @return {Class}
    */


    DBConnection.prototype.model = function(name, schema) {
      return this.models[name] = DBModel.newModel(this, name, schema);
    };

    DBConnection.prototype._waitingForConnection = function(object, method, args) {
      if (this.connected) {
        return false;
      }
      this.once('connected', function() {
        return method.apply(object, args);
      });
      return true;
    };

    DBConnection.prototype._waitingForApplyingSchemas = function(object, method, args) {
      if (!this._applying_schemas) {
        return false;
      }
      this.once('schemas_applied', function() {
        return method.apply(object, args);
      });
      return true;
    };

    /*
      # Applies schemas
      # @param {Function} [callback]
      # @param {Error} callback.error
    */


    DBConnection.prototype.applySchemas = function(callback) {
      var callAdapter,
        _this = this;
      if ((this._adapter.applySchemas != null) && !this._applying_schemas) {
        this._applying_schemas = true;
        callAdapter = function() {
          return _this._adapter.applySchemas(function(error) {
            _this._applying_schemas = false;
            _this.emit('schemas_applied');
            return typeof callback === "function" ? callback(error) : void 0;
          });
        };
        if (this._waitingForConnection(this, callAdapter, arguments)) {
          return;
        }
        return callAdapter();
      } else {
        return typeof callback === "function" ? callback(null) : void 0;
      }
    };

    return DBConnection;

  })(EventEmitter);

  _ref = require('./types');
  for (type in _ref) {
    value = _ref[type];
    DBConnection[type] = value;
    DBConnection.prototype[type] = value;
  }

  module.exports = DBConnection;

}).call(this);
