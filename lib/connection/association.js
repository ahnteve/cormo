// Generated by CoffeeScript 1.7.1
(function() {
  var ConnectionAssociation, async, inflector, types, _;

  _ = require('underscore');

  async = require('async');

  inflector = require('../inflector');

  types = require('../types');

  ConnectionAssociation = (function() {
    function ConnectionAssociation() {}

    ConnectionAssociation.prototype._hasMany = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key, integrity;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      integrity = (options != null ? options.integrity : void 0) || 'ignore';
      target_model._integrities.push({
        type: 'child_' + integrity,
        column: foreign_key,
        parent: this_model
      });
      this_model._integrities.push({
        type: 'parent_' + integrity,
        column: foreign_key,
        child: target_model
      });
      column = (options != null ? options.as : void 0) || inflector.tableize(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasMany',
        target_model: target_model,
        foreign_key: foreign_key
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var conditions, self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self.id) {
                conditions = {};
                conditions[foreign_key] = self.id;
                return target_model.where(conditions, function(error, records) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = records;
                  return callback(null, records);
                });
              } else {
                return callback(null, self[columnCache] || []);
              }
            };
            getter.build = function(data) {
              var new_object, self;
              self = getter.__scope;
              new_object = new target_model(data);
              new_object[foreign_key] = self.id;
              if (!self[columnCache]) {
                self[columnCache] = [];
              }
              self[columnCache].push(new_object);
              return new_object;
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._hasOne = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key, integrity;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      integrity = (options != null ? options.integrity : void 0) || 'ignore';
      target_model._integrities.push({
        type: 'child_' + integrity,
        column: foreign_key,
        parent: this_model
      });
      this_model._integrities.push({
        type: 'parent_' + integrity,
        column: foreign_key,
        child: target_model
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasOne',
        target_model: target_model
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var conditions, self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self.id) {
                conditions = {};
                conditions[foreign_key] = self.id;
                return target_model.where(conditions, function(error, records) {
                  var record;
                  if (error) {
                    return callback(error);
                  }
                  if (records.length > 1) {
                    return callback(new Error('integrity error'));
                  }
                  record = records.length === 0 ? null : records[0];
                  self[columnCache] = record;
                  return callback(null, record);
                });
              } else {
                return callback(null, self[columnCache]);
              }
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._belongsTo = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(target_model._name);
      }
      this_model.column(foreign_key, {
        type: types.RecordID,
        connection: target_model._connection,
        required: options != null ? options.required : void 0
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'belongsTo',
        target_model: target_model
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self[foreign_key]) {
                return target_model.find(self[foreign_key], function(error, record) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = record;
                  return callback(null, record);
                });
              } else {
                return callback(null, self[columnCache]);
              }
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._applyAssociations = function() {
      this._pending_associations.forEach((function(_this) {
        return function(item) {
          var models, options, target_model, this_model, _ref, _ref1;
          this_model = item.this_model;
          options = item.options;
          if (typeof item.target_model_or_column === 'string') {
            if ((_ref = item.options) != null ? _ref.connection : void 0) {
              models = item.options.connection.models;
            } else {
              models = _this.models;
            }
            if ((_ref1 = item.options) != null ? _ref1.type : void 0) {
              target_model = item.options.type;
              options.as = item.target_model_or_column;
            } else if (item.type === 'belongsTo' || item.type === 'hasOne') {
              target_model = inflector.camelize(item.target_model_or_column);
            } else {
              target_model = inflector.classify(item.target_model_or_column);
            }
            if (!models[target_model]) {
              throw new Error("model " + target_model + " does not exist");
            }
            target_model = models[target_model];
          } else {
            target_model = item.target_model_or_column;
          }
          return _this['_' + item.type](this_model, target_model, options);
        };
      })(this));
      return this._pending_associations = [];
    };

    ConnectionAssociation.prototype.addAssociation = function(association) {
      this._pending_associations.push(association);
      return this._schema_changed = true;
    };

    ConnectionAssociation.prototype.getInconsistencies = function(callback) {
      var result;
      if (this._waitingForApplyingSchemas(this, this.getInconsistencies, arguments)) {
        return;
      }
      result = {};
      return async.forEach(Object.keys(this.models), (function(_this) {
        return function(model, callback) {
          var integrities, modelClass;
          modelClass = _this.models[model];
          integrities = modelClass._integrities.filter(function(integrity) {
            return integrity.type.substr(0, 7) === 'parent_';
          });
          if (integrities.length > 0) {
            return modelClass.select('', function(error, records) {
              var ids;
              ids = records.map(function(record) {
                return record.id;
              });
              return async.forEach(integrities, function(integrity, callback) {
                var conditions, property, query;
                query = integrity.child.select('');
                conditions = {};
                conditions[integrity.column] = {
                  $not: {
                    $in: ids
                  }
                };
                query.where(conditions);
                property = integrity.child._schema[integrity.column];
                if (!property.required) {
                  conditions = {};
                  conditions[integrity.column] = {
                    $not: null
                  };
                  query.where(conditions);
                }
                return query.exec(function(error, records) {
                  var array, _name;
                  if (error) {
                    return callback(error);
                  }
                  if (records.length === 0) {
                    return callback(null);
                  }
                  array = result[_name = integrity.child._name] || (result[_name] = []);
                  [].push.apply(array, records.map(function(record) {
                    return record.id;
                  }));
                  _.uniq(array);
                  return callback(null);
                });
              }, function(error) {
                return callback(null);
              });
            });
          } else {
            return callback(null);
          }
        };
      })(this), function(error) {
        if (error) {
          return callback(error);
        }
        return callback(null, result);
      });
    };

    ConnectionAssociation.prototype._fetchAssociatedBelongsTo = function(records, target_model, column, select, options, callback) {
      var id, id_column, id_to_record_map, ids, query;
      id_column = column + '_id';
      if (Array.isArray(records)) {
        id_to_record_map = {};
        records.forEach(function(record) {
          var id;
          id = record[id_column];
          if (id) {
            (id_to_record_map[id] || (id_to_record_map[id] = [])).push(record);
          } else if (!record.hasOwnProperty(column)) {
            Object.defineProperty(record, column, {
              enumerable: true,
              value: null
            });
          }
        });
        ids = Object.keys(id_to_record_map);
        query = target_model.find(ids);
        if (select) {
          query.select(select);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec(function(error, sub_records) {
          if (error) {
            return callback(null);
          }
          sub_records.forEach(function(sub_record) {
            return id_to_record_map[sub_record.id].forEach(function(record) {
              return Object.defineProperty(record, column, {
                enumerable: true,
                value: sub_record
              });
            });
          });
          return callback(null);
        });
      } else {
        id = records[id_column];
        if (id) {
          query = target_model.find(id);
          if (select) {
            query.select(select);
          }
          if (options.lean) {
            query.lean();
          }
          return query.exec(function(error, sub_record) {
            if (error) {
              return callback(error);
            }
            Object.defineProperty(records, column, {
              enumerable: true,
              value: sub_record
            });
            return callback(null);
          });
        } else if (!records.hasOwnProperty(column)) {
          Object.defineProperty(records, column, {
            enumerable: true,
            value: null
          });
          return callback(null);
        }
      }
    };

    ConnectionAssociation.prototype._fetchAssociatedHasMany = function(records, target_model, foreign_key, column, select, options, callback) {
      var cond, ids, query;
      if (Array.isArray(records)) {
        ids = records.map(function(record) {
          Object.defineProperty(record, column, {
            enumerable: true,
            value: []
          });
          return record.id;
        });
        cond = {};
        cond[foreign_key] = {
          $in: ids
        };
        query = target_model.where(cond);
        if (select) {
          query.select(select + ' ' + foreign_key);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec(function(error, sub_records) {
          if (error) {
            return callback(null);
          }
          sub_records.forEach(function(sub_record) {
            return records.forEach(function(record) {
              if (record.id === sub_record[foreign_key]) {
                return record[column].push(sub_record);
              }
            });
          });
          return callback(null);
        });
      } else {
        Object.defineProperty(records, column, {
          enumerable: true,
          value: []
        });
        cond = {};
        cond[foreign_key] = records.id;
        query = target_model.where(cond);
        if (select) {
          query.select(select + ' ' + foreign_key);
        }
        if (options.lean) {
          query.lean();
        }
        return query.exec(function(error, sub_records) {
          if (error) {
            return callback(null);
          }
          sub_records.forEach(function(sub_record) {
            return records[column].push(sub_record);
          });
          return callback(null);
        });
      }
    };

    ConnectionAssociation.prototype.fetchAssociated = function(records, column, select, options, callback) {
      var association, record, _ref;
      if (typeof select === 'function') {
        callback = select;
        options = {};
        select = null;
      } else if (typeof options === 'function') {
        callback = options;
        options = {};
        if (typeof select === 'object') {
          options = select;
          select = null;
        }
      }
      record = Array.isArray(records) ? records[0] : records;
      if (!record) {
        return callback(null);
      }
      association = (_ref = (options.model || record.constructor)._associations) != null ? _ref[column] : void 0;
      if (!association) {
        return callback(new Error("unknown column '" + column + "'"));
      }
      if (association.type === 'belongsTo') {
        return this._fetchAssociatedBelongsTo(records, association.target_model, column, select, options, callback);
      } else if (association.type === 'hasMany') {
        return this._fetchAssociatedHasMany(records, association.target_model, association.foreign_key, column, select, options, callback);
      } else {
        return callback(new Error("unknown column '" + column + "'"));
      }
    };

    return ConnectionAssociation;

  })();

  module.exports = ConnectionAssociation;

}).call(this);
