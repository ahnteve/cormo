// Generated by CoffeeScript 1.4.0
(function() {
  var ConnectionAssociation, async, inflector, types, _;

  _ = require('underscore');

  async = require('async');

  inflector = require('../inflector');

  types = require('../types');

  ConnectionAssociation = (function() {

    function ConnectionAssociation() {}

    ConnectionAssociation.prototype._hasMany = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key, integrity;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      integrity = (options != null ? options.integrity : void 0) || 'ignore';
      target_model._integrities.push({
        type: 'child_' + integrity,
        column: foreign_key,
        parent: this_model
      });
      this_model._integrities.push({
        type: 'parent_' + integrity,
        column: foreign_key,
        child: target_model
      });
      column = (options != null ? options.as : void 0) || inflector.tableize(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasMany'
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var conditions, self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self.id) {
                conditions = {};
                conditions[foreign_key] = self.id;
                return target_model.where(conditions, function(error, records) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = records;
                  return callback(null, records);
                });
              } else {
                return callback(null, self[columnCache] || []);
              }
            };
            getter.build = function(data) {
              var new_object, self;
              self = getter.__scope;
              new_object = new target_model(data);
              new_object[foreign_key] = self.id;
              if (!self[columnCache]) {
                self[columnCache] = [];
              }
              self[columnCache].push(new_object);
              return new_object;
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._belongsTo = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(target_model._name);
      }
      this_model.column(foreign_key, {
        type: types.RecordID,
        connection: target_model._connection,
        required: options != null ? options.required : void 0
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self[foreign_key]) {
                return target_model.find(self[foreign_key], function(error, record) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = record;
                  return callback(null, record);
                });
              } else {
                return callback(null, self[columnCache]);
              }
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._applyAssociations = function() {
      var _this = this;
      this._pending_associations.forEach(function(item) {
        var models, options, target_model, this_model, _ref, _ref1;
        this_model = item.this_model;
        options = item.options;
        if (typeof item.target_model_or_column === 'string') {
          if ((_ref = item.options) != null ? _ref.connection : void 0) {
            models = item.options.connection.models;
          } else {
            models = _this.models;
          }
          if ((_ref1 = item.options) != null ? _ref1.type : void 0) {
            target_model = item.options.type;
            options.as = item.target_model_or_column;
          } else if (item.type === 'belongsTo') {
            target_model = inflector.camelize(item.target_model_or_column);
          } else {
            target_model = inflector.classify(item.target_model_or_column);
          }
          if (!models[target_model]) {
            throw new Error("model " + target_model + " does not exist");
          }
          target_model = models[target_model];
        } else {
          target_model = item.target_model_or_column;
        }
        return _this['_' + item.type](this_model, target_model, options);
      });
      return this._pending_associations = [];
    };

    ConnectionAssociation.prototype.addAssociation = function(association) {
      this._pending_associations.push(association);
      return this._schema_changed = true;
    };

    ConnectionAssociation.prototype.getInconsistencies = function(callback) {
      var result,
        _this = this;
      if (this._waitingForApplyingSchemas(this, this.getInconsistencies, arguments)) {
        return;
      }
      result = {};
      return async.forEach(Object.keys(this.models), function(model, callback) {
        var integrities, modelClass;
        modelClass = _this.models[model];
        integrities = modelClass._integrities.filter(function(integrity) {
          return integrity.type.substr(0, 7) === 'parent_';
        });
        if (integrities.length > 0) {
          return modelClass.select('', function(error, records) {
            var ids;
            ids = records.map(function(record) {
              return record.id;
            });
            return async.forEach(integrities, function(integrity, callback) {
              var conditions, property, query;
              query = integrity.child.select('');
              conditions = {};
              conditions[integrity.column] = {
                $not: {
                  $in: ids
                }
              };
              query.where(conditions);
              property = integrity.child._schema[integrity.column];
              if (!property.required) {
                conditions = {};
                conditions[integrity.column] = {
                  $not: null
                };
                query.where(conditions);
              }
              return query.exec(function(error, records) {
                var array, _name;
                if (error) {
                  return callback(error);
                }
                if (records.length === 0) {
                  return callback(null);
                }
                array = result[_name = integrity.child._name] || (result[_name] = []);
                [].push.apply(array, records.map(function(record) {
                  return record.id;
                }));
                _.uniq(array);
                return callback(null);
              });
            }, function(error) {
              return callback(null);
            });
          });
        } else {
          return callback(null);
        }
      }, function(error) {
        if (error) {
          return callback(error);
        }
        return callback(null, result);
      });
    };

    return ConnectionAssociation;

  })();

  module.exports = ConnectionAssociation;

}).call(this);
