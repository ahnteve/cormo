// Generated by CoffeeScript 1.4.0
(function() {
  var ConnectionAssociation, inflector, types;

  inflector = require('../inflector');

  types = require('../types');

  ConnectionAssociation = (function() {

    function ConnectionAssociation() {}

    ConnectionAssociation.prototype._hasMany = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this_model._name);
      }
      target_model.column(foreign_key, {
        type: types.RecordID,
        connection: this_model._connection
      });
      column = (options != null ? options.as : void 0) || inflector.tableize(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this_model._associations[column] = {
        type: 'hasMany'
      };
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var conditions, self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self.id) {
                conditions = {};
                conditions[foreign_key] = self.id;
                return target_model.where(conditions, function(error, records) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = records;
                  return callback(null, records);
                });
              } else {
                return callback(null, self[columnCache] || []);
              }
            };
            getter.build = function(data) {
              var new_object, self;
              self = getter.__scope;
              new_object = new target_model(data);
              new_object[foreign_key] = self.id;
              if (!self[columnCache]) {
                self[columnCache] = [];
              }
              self[columnCache].push(new_object);
              return new_object;
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._belongsTo = function(this_model, target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(target_model._name);
      }
      this_model.column(foreign_key, {
        type: types.RecordID,
        connection: target_model._connection
      });
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      return Object.defineProperty(this_model.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self[foreign_key]) {
                return target_model.find(self[foreign_key], function(error, record) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = record;
                  return callback(null, record);
                });
              } else {
                return callback(null, self[columnCache]);
              }
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    ConnectionAssociation.prototype._applyAssociations = function(connection, associations) {
      var _this = this;
      return associations.forEach(function(item) {
        var models, options, target_model, this_model, _ref, _ref1;
        this_model = item.this_model;
        options = item.options;
        if (typeof item.target_model_or_column === 'string') {
          if ((_ref = item.options) != null ? _ref.connection : void 0) {
            models = item.options.connection.models;
          } else {
            models = connection.models;
          }
          if ((_ref1 = item.options) != null ? _ref1.type : void 0) {
            target_model = item.options.type;
            options.as = item.target_model_or_column;
          } else if (item.type === 'belongsTo') {
            target_model = inflector.camelize(item.target_model_or_column);
          } else {
            target_model = inflector.classify(item.target_model_or_column);
          }
          if (!models[target_model]) {
            throw new Error("model " + target_model + " does not exist");
          }
          target_model = models[target_model];
        } else {
          target_model = item.target_model_or_column;
        }
        return _this['_' + item.type](this_model, target_model, options);
      });
    };

    return ConnectionAssociation;

  })();

  module.exports = ConnectionAssociation;

}).call(this);
