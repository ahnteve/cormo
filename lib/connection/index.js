// Generated by CoffeeScript 2.3.1
var Connection, ConnectionAssociationMixin, ConnectionBase, ConnectionManipulateMixin, EventEmitter, Model, Promise, Toposort, _, bindDomain, deasync, inspect, redis;

EventEmitter = require('events').EventEmitter;

Model = require('../model');

_ = require('lodash');

({bindDomain} = require('../util'));

Promise = require('bluebird');

Toposort = require('toposort-class');

try {
  redis = require('redis');
} catch (error1) {}

({inspect} = require('util'));

try {
  deasync = require('deasync');
} catch (error1) {}

ConnectionBase = (function() {
  //#
  // Manages connection to a database
  // @uses ConnectionAssociation
  // @uses ConnectionManipulate
  class ConnectionBase extends EventEmitter {
    //#
    // Default connection
    // @property defaultConnection
    // @type Connection
    // @static
    // @see Connection::constructor

    //#
    // Indicates the adapter associated to this connection
    // @property _adapter
    // @type AdapterBase
    // @private
    // @see Connection::constructor

    //#
    // Model lists using this connection.
    // Maps from model name to model class
    // @property models
    // @type StringMap<Class<Model>>
    // @see Connection::constructor

    //#
    // Creates a connection
    // @param {String} adapater_name
    // @param {Object} settings connection settings & adapter specific settings
    // @param {Boolean} [settings.is_default=true] Connection.defaultConnection will be set to this if true
    // @param {Object} [settings.redis_cache] Redis server settings to cache
    // @param {RedisClient} [settings.redis_cache.client] Use this client instead of creating one
    // @param {String} [settings.redis_cache.host='127.0.0.1']
    // @param {Number} [settings.redis_cache.port=6379]
    // @param {Number} [settings.redis_cache.database=0]
    // @see MySQLAdapter::connect
    // @see MongoDBAdapter::connect
    // @see PostgreSQLAdapter::connect
    // @see SQLite3Adapter::connect
    // @see RedisAdapter::connect
    constructor(adapter_name, settings) {
      var redis_cache;
      super();
      if (settings.is_default !== false) {
        Connection.defaultConnection = this;
      }
      redis_cache = settings.redis_cache || {};
      this._redis_cache_settings = redis_cache;
      this.connected = false;
      this.models = {};
      this._pending_associations = [];
      this._schema_changed = false;
      this._adapter = Promise.promisifyAll(require(__dirname + '/../adapters/' + adapter_name)(this));
      this._promise_connection = this._adapter.connectAsync(settings).then(() => {
        return this.connected = true;
      }).catch((error) => {
        this._adapter = null;
        return Promise.reject(error);
      });
      Object.defineProperty(this, 'adapter', {
        get: function() {
          return this._adapter;
        }
      });
    }

    //#
    // Closes this connection.
    // A closed connection can be used no more.
    close() {
      if (Connection.defaultConnection === this) {
        Connection.defaultConnection = null;
      }
      this._adapter.close();
      return this._adapter = null;
    }

    //#
    // Creates a model class
    // @param {String} name
    // @param {Object} schema
    // @return {Class<Model>}
    model(name, schema) {
      return Model.newModel(this, name, schema);
    }

    _checkSchemaApplied() {
      this._initializeModels();
      if (!this._applying_schemas && !this._schema_changed) {
        return Promise.resolve();
      }
      return this.applySchemas();
    }

    _initializeModels() {
      var model, modelClass, ref;
      ref = this.models;
      for (model in ref) {
        modelClass = ref[model];
        if (modelClass.initialize && !modelClass._initialize_called) {
          modelClass.initialize();
          modelClass._initialize_called = true;
        }
      }
    }

    _checkArchive() {
      var _Archive, model, modelClass, ref;
      ref = this.models;
      for (model in ref) {
        modelClass = ref[model];
        if (modelClass.archive && !modelClass._connection.models.hasOwnProperty('_Archive')) {
          _Archive = (function() {
            class _Archive extends Model {};

            _Archive.connection(modelClass._connection);

            _Archive.archive = false;

            _Archive.column('model', String);

            _Archive.column('data', Object);

            return _Archive;

          }).call(this);
        }
      }
    }

    _getModelNamesByAssociationOrder() {
      var t;
      t = new Toposort();
      Object.keys(this.models).forEach((model) => {
        var association, modelClass, name, ref, ref1, results;
        t.add(model, []);
        modelClass = this.models[model];
        ref = modelClass._associations;
        results = [];
        for (name in ref) {
          association = ref[name];
          // ignore association with models of other connection
          if (association.target_model._connection !== this) {
            continue;
          }
          // ignore self association
          if (association.target_model === modelClass) {
            continue;
          }
          if ((ref1 = association.type) === 'hasMany' || ref1 === 'hasOne') {
            results.push(t.add(association.target_model._name, model));
          } else if (association.type === 'belongsTo') {
            results.push(t.add(model, association.target_model._name));
          } else {
            results.push(void 0);
          }
        }
        return results;
      });
      return t.sort();
    }

    //#
    // Applies schemas
    // @param {Object} [options]
    // @param {Boolean} [options.verbose=false]
    // @promise
    // @nodejscallback
    // @see AdapterBase::applySchema
    applySchemas(options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      } else if (!options) {
        options = {};
      }
      return Promise.resolve().then(() => {
        this._initializeModels();
        if (!this._schema_changed) {
          return;
        }
        this._applyAssociations();
        if (!this._applying_schemas) {
          this._applying_schemas = true;
          this._checkArchive();
          if (options.verbose) {
            console.log('Applying schemas');
          }
          this._promise_schema_applied = this._promise_connection.then(() => {
            return this._adapter.getSchemasAsync().tap((current) => {
              var add_columns_commands, column, model, modelClass, property, ref, ref1, ref2, ref3, ref4, ref5;
              add_columns_commands = [];
              ref = this.models;
              for (model in ref) {
                modelClass = ref[model];
                if (!((ref1 = current.tables) != null ? ref1[modelClass.tableName] : void 0) || ((ref2 = current.tables) != null ? ref2[modelClass.tableName] : void 0) === 'NO SCHEMA') {
                  continue;
                }
                ref3 = modelClass._schema;
                for (column in ref3) {
                  property = ref3[column];
                  if (!((ref4 = current.tables) != null ? (ref5 = ref4[modelClass.tableName]) != null ? ref5[property._dbname] : void 0 : void 0)) {
                    if (options.verbose) {
                      console.log(`Adding column ${column} to ${modelClass.tableName}`);
                    }
                    add_columns_commands.push(this._adapter.addColumnAsync(model, property));
                  }
                }
              }
              return Promise.all(add_columns_commands);
            }).tap((current) => {
              var model, modelClass, ref, tables_commands;
              tables_commands = [];
              ref = this.models;
              for (model in ref) {
                modelClass = ref[model];
                if (!current.tables[modelClass.tableName]) {
                  if (options.verbose) {
                    console.log(`Creating table ${modelClass.tableName}`);
                  }
                  tables_commands.push(this._adapter.createTableAsync(model));
                }
              }
              return Promise.all(tables_commands);
            }).tap((current) => {
              var i, index, indexes_commands, len, model, modelClass, ref, ref1, ref2, ref3;
              indexes_commands = [];
              ref = this.models;
              for (model in ref) {
                modelClass = ref[model];
                ref1 = modelClass._indexes;
                for (i = 0, len = ref1.length; i < len; i++) {
                  index = ref1[i];
                  if (!((ref2 = current.indexes) != null ? (ref3 = ref2[modelClass.tableName]) != null ? ref3[index.options.name] : void 0 : void 0)) {
                    if (options.verbose) {
                      console.log(`Creating index on ${modelClass.tableName} ${Object.keys(index.columns)}`);
                    }
                    indexes_commands.push(this._adapter.createIndexAsync(model, index));
                  }
                }
              }
              return Promise.all(indexes_commands);
            }).tap((current) => {
              var current_foreign_key, foreign_keys_commands, i, integrity, len, model, modelClass, ref, ref1, ref2, ref3, type;
              foreign_keys_commands = [];
              ref = this.models;
              for (model in ref) {
                modelClass = ref[model];
                ref1 = modelClass._integrities;
                for (i = 0, len = ref1.length; i < len; i++) {
                  integrity = ref1[i];
                  type = '';
                  if (integrity.type === 'child_nullify') {
                    type = 'nullify';
                  } else if (integrity.type === 'child_restrict') {
                    type = 'restrict';
                  } else if (integrity.type === 'child_delete') {
                    type = 'delete';
                  }
                  if (type) {
                    current_foreign_key = (ref2 = current.foreign_keys) != null ? (ref3 = ref2[modelClass.tableName]) != null ? ref3[integrity.column] : void 0 : void 0;
                    if (!(current_foreign_key && current_foreign_key === integrity.parent.tableName)) {
                      if (options.verbose) {
                        console.log(`Adding foreign key ${modelClass.tableName}.${integrity.column} to ${integrity.parent.tableName}`);
                      }
                      foreign_keys_commands.push([model, integrity.column, type, integrity.parent]);
                    }
                  }
                }
              }
              return Promise.each(foreign_keys_commands, (args) => {
                return this._adapter.createForeignKeyAsync.apply(this._adapter, args);
              });
            }).finally(() => {
              if (options.verbose) {
                console.log('Applying schemas done');
              }
              this._applying_schemas = false;
              return this._schema_changed = false;
            });
          });
        }
        return this._promise_schema_applied;
      }).nodeify(bindDomain(callback));
    }

    //#
    // Drops all model tables
    // @promise
    // @nodejscallback
    dropAllModels(callback) {
      var current;
      current = Promise.resolve();
      return Promise.all(this._getModelNamesByAssociationOrder().map((model) => {
        return current = current.then(() => {
          return this.models[model].drop();
        });
      })).nodeify(bindDomain(callback));
    }

    //#
    // Logs
    // @param {String} model
    // @param {String} type
    // @param {Object} data
    log(model, type, data) {}

    _connectRedisCache() {
      var client, settings;
      if (this._redis_cache_client) {
        return Promise.resolve(this._redis_cache_client);
      } else if (!redis) {
        return Promise.reject(new Error('cache needs Redis'));
      } else {
        settings = this._redis_cache_settings;
        this._redis_cache_client = client = settings.client || (redis.createClient(settings.port || 6379, settings.host || '127.0.0.1'));
        if (settings.database != null) {
          client.select(settings.database);
          client.once('connect', function() {
            client.send_anyways = true;
            client.select(settings.database);
            return client.send_anyways = false;
          });
        }
        return Promise.resolve(client);
      }
    }

    inspect(depth) {
      return inspect(this.models);
    }

  };

  //#
  // Applies schemas synchronously
  // @method
  // @see Connection::applySchemas
  ConnectionBase.prototype.applySchemasSync = typeof deasync === "function" ? deasync(ConnectionBase.prototype.applySchemas) : void 0;

  return ConnectionBase;

}).call(this);

ConnectionAssociationMixin = require('./association');

ConnectionManipulateMixin = require('./manipulate');

Connection = class Connection extends ConnectionAssociationMixin(ConnectionManipulateMixin(ConnectionBase)) {};

Model._Connection = Connection;

module.exports = Connection;
