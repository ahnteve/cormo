// Generated by CoffeeScript 1.7.1
(function() {
  var Connection, Model, Promise, Query, addArgCompleter, addHistory, addMultilineHandler, coffee, evalCoffee, fs, path, prettyErrorMessage, repl, setupContext, util, vm;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  repl = require('repl');

  vm = require('vm');

  util = require('util');

  Connection = require('./connection');

  Model = require('./model');

  Query = require('./query');

  prettyErrorMessage = coffee.helpers.prettyErrorMessage || function(e) {
    return e;
  };

  addMultilineHandler = function(repl_server) {
    var inputStream, multiline, nodeLineListener, outputStream, rli;
    rli = repl_server.rli, inputStream = repl_server.inputStream, outputStream = repl_server.outputStream;
    multiline = {
      enabled: false,
      initialPrompt: repl_server.prompt.replace(/^[^> ]*/, function(x) {
        return x.replace(/./g, '-');
      }),
      prompt: repl_server.prompt.replace(/^[^> ]*>?/, function(x) {
        return x.replace(/./g, '.');
      }),
      buffer: ''
    };
    nodeLineListener = rli.listeners('line')[0];
    rli.removeListener('line', nodeLineListener);
    rli.on('line', function(cmd) {
      if (multiline.enabled) {
        multiline.buffer += "" + cmd + "\n";
        rli.setPrompt(multiline.prompt);
        rli.prompt(true);
      } else {
        nodeLineListener(cmd);
      }
    });
    return inputStream.on('keypress', function(char, key) {
      if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {
        return;
      }
      if (multiline.enabled) {
        if (!multiline.buffer.match(/\n/)) {
          multiline.enabled = !multiline.enabled;
          rli.setPrompt(repl_server.prompt);
          rli.prompt(true);
          return;
        }
        if ((rli.line != null) && !rli.line.match(/^\s*$/)) {
          return;
        }
        multiline.enabled = !multiline.enabled;
        rli.line = '';
        rli.cursor = 0;
        rli.output.cursorTo(0);
        rli.output.clearLine(1);
        multiline.buffer = multiline.buffer.replace(/\n/g, '\uFF00');
        rli.emit('line', multiline.buffer);
        multiline.buffer = '';
      } else {
        multiline.enabled = !multiline.enabled;
        rli.setPrompt(multiline.initialPrompt);
        rli.prompt(true);
      }
    });
  };

  addHistory = function(repl_server, filename, maxSize) {
    var buffer, fd, lastLine, readFd, size, stat;
    lastLine = null;
    try {
      stat = fs.statSync(filename);
      size = Math.min(maxSize, stat.size);
      readFd = fs.openSync(filename, 'r');
      buffer = new Buffer(size);
      fs.readSync(readFd, buffer, 0, size, stat.size - size);
      fs.closeSync(readFd);
      repl_server.rli.history = buffer.toString().split('\n').reverse();
      if (stat.size > maxSize) {
        repl_server.rli.history.pop();
      }
      if (repl_server.rli.history[0] === '') {
        repl_server.rli.history.shift();
      }
      repl_server.rli.historyIndex = -1;
      lastLine = repl_server.rli.history[0];
    } catch (_error) {}
    fd = fs.openSync(filename, 'a');
    repl_server.rli.addListener('line', function(code) {
      if (code && code.length && code !== '.history' && lastLine !== code) {
        fs.write(fd, "" + code + "\n");
        return lastLine = code;
      }
    });
    repl_server.rli.on('close', function() {
      return fs.close(fd);
    });
    return repl_server.commands['.history'] = {
      help: 'Show command history',
      action: function() {
        repl_server.outputStream.write("" + (repl_server.rli.history.slice(0).reverse().join('\n')) + "\n");
        return repl_server.displayPrompt();
      }
    };
  };

  addArgCompleter = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write("" + (line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  evalCoffee = function(cmd, context, filename, callback) {
    var assign_to;
    cmd = cmd.replace(/\uFF00/g, '\n');
    cmd = cmd.replace(/^\(([\s\S]*)\n\)$/m, '$1');
    if (!cmd) {
      return callback(null);
    }
    if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
      assign_to = RegExp.$1;
    }
    return Promise["try"](function() {
      var defer, js, result;
      if (/[, ]\$$/.test(cmd)) {
        defer = Promise.defer();
        context.$ = defer.callback;
      }
      js = coffee.compile(cmd, {
        filename: filename,
        bare: true
      });
      result = vm.runInContext(js, context, filename);
      if (defer) {
        delete context.$;
        return defer.promise;
      } else if (result instanceof Query) {
        return result.exec();
      } else {
        return result;
      }
    }).then(function(result) {
      if (assign_to) {
        context[assign_to] = result;
      }
      return callback(null, result);
    })["catch"](function(error) {
      return callback(prettyErrorMessage(error, filename, cmd, true));
    });
  };

  setupContext = function(context, options) {
    var connection, key, model, modelClass, object, _ref, _ref1;
    context.Connection = Connection;
    context.Model = Model;
    context.connection = connection = Connection.defaultConnection;
    if (connection) {
      _ref = connection.models;
      for (model in _ref) {
        modelClass = _ref[model];
        context[model] = modelClass;
      }
      connection.applySchemas();
    }
    Object.defineProperty(context.console, 'inspect_depth', {
      enumrable: true,
      get: (function(_this) {
        return function() {
          return options.inspect_depth;
        };
      })(this),
      set: (function(_this) {
        return function(value) {
          return options.inspect_depth = value;
        };
      })(this)
    });
    _ref1 = exports["public"];
    for (key in _ref1) {
      object = _ref1[key];
      context[key] = object;
    }
    context.getTimestamp = function(object_id) {
      return new Date(parseInt(object_id.substr(0, 8), 16) * 1000);
    };
  };

  exports["public"] = {};

  exports.startCoffee = function(options) {
    var historyFile, repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      "eval": evalCoffee,
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true
    });
    addMultilineHandler(repl_server);
    if (process.env.HOME) {
      historyFile = path.join(process.env.HOME, '.cormo_history');
    }
    if (historyFile) {
      addHistory(repl_server, historyFile, 10240);
    }
    addArgCompleter(repl_server);
    setupContext(repl_server.context, options);
    return repl_server;
  };

}).call(this);
