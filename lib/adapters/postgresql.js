// Generated by CoffeeScript 1.6.2
(function() {
  var PostgreSQLAdapter, SQLAdapterBase, async, e, pg, types, _, _propertyToSQL, _typeToSQL,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    pg = require('pg');
  } catch (_error) {
    e = _error;
    console.log('Install pg module to use this adapter');
    process.exit(1);
  }

  SQLAdapterBase = require('./sql_base');

  types = require('../types');

  async = require('async');

  _ = require('underscore');

  _typeToSQL = function(property) {
    if (property.array) {
      return 'VARCHAR(255)';
    }
    switch (property.type) {
      case types.String:
        return 'VARCHAR(255)';
      case types.Number:
        return 'DOUBLE PRECISION';
      case types.Boolean:
        return 'BOOLEAN';
      case types.Integer:
        return 'INT';
      case types.Date:
        return 'TIMESTAMP WITHOUT TIME ZONE';
      case types.Object:
        return 'VARCHAR(255)';
    }
  };

  _propertyToSQL = function(property) {
    var type;

    type = _typeToSQL(property);
    if (type) {
      if (property.required) {
        type += ' NOT NULL';
      } else {
        type += ' NULL';
      }
      if (property.unique) {
        type += ' UNIQUE';
      }
      return type;
    }
  };

  PostgreSQLAdapter = (function(_super) {
    var _processSaveError;

    __extends(PostgreSQLAdapter, _super);

    PostgreSQLAdapter.prototype.key_type = types.Integer;

    PostgreSQLAdapter.prototype.native_integrity = true;

    PostgreSQLAdapter.prototype._param_place_holder = function(pos) {
      return '$' + pos;
    };

    PostgreSQLAdapter.prototype._contains_op = 'ILIKE';

    function PostgreSQLAdapter(connection) {
      this._connection = connection;
    }

    PostgreSQLAdapter.prototype._query = function(sql, data, callback) {
      return this._client.query(sql, data, function(error, result) {
        return callback(error, result);
      });
    };

    PostgreSQLAdapter.prototype._createTable = function(model, callback) {
      var column, column_sql, integrity, model_class, property, sql, tableName, _i, _len, _ref, _ref1,
        _this = this;

      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      sql = [];
      sql.push('id SERIAL PRIMARY KEY');
      _ref = model_class._schema;
      for (column in _ref) {
        property = _ref[column];
        column_sql = _propertyToSQL(property);
        if (column_sql) {
          sql.push(property._dbname + ' ' + column_sql);
        }
      }
      _ref1 = model_class._integrities;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        integrity = _ref1[_i];
        if (integrity.type === 'child_nullify') {
          sql.push("FOREIGN KEY (" + integrity.column + ") REFERENCES " + integrity.parent.tableName + "(id) ON DELETE SET NULL");
        } else if (integrity.type === 'child_restrict') {
          sql.push("FOREIGN KEY (" + integrity.column + ") REFERENCES " + integrity.parent.tableName + "(id) ON DELETE RESTRICT");
        } else if (integrity.type === 'child_delete') {
          sql.push("FOREIGN KEY (" + integrity.column + ") REFERENCES " + integrity.parent.tableName + "(id) ON DELETE CASCADE");
        }
      }
      sql = "CREATE TABLE " + tableName + " ( " + (sql.join(',')) + " )";
      return this._query(sql, null, function(error) {
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        return async.forEach(model_class._indexes, function(index, callback) {
          var columns, order, unique, _ref2;

          columns = [];
          _ref2 = index.columns;
          for (column in _ref2) {
            order = _ref2[column];
            order = order === -1 ? 'DESC' : 'ASC';
            columns.push(column + ' ' + order);
          }
          unique = index.options.unique ? 'UNIQUE ' : '';
          sql = "CREATE " + unique + "INDEX " + index.options.name + " ON " + tableName + " (" + (columns.join(',')) + ")";
          return _this._query(sql, null, callback);
        }, function(error) {
          if (error) {
            return callback(PostgreSQLAdapter.wrapError('unknown error', error));
          }
          return callback(null);
        });
      });
    };

    PostgreSQLAdapter.prototype._alterTable = function(model, columns, callback) {
      return callback(null);
    };

    PostgreSQLAdapter.prototype.applySchema = function(model, callback) {
      var tableName,
        _this = this;

      tableName = this._connection.models[model].tableName;
      return this._query("SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name=$1", [tableName], function(error, result) {
        var columns;

        columns = result != null ? result.rows : void 0;
        if (error || columns.length === 0) {
          return _this._createTable(model, callback);
        } else {
          return _this._alterTable(model, columns, callback);
        }
      });
    };

    PostgreSQLAdapter.prototype.drop = function(model, callback) {
      var tableName;

      tableName = this._connection.models[model].tableName;
      return this._query("DROP TABLE IF EXISTS " + tableName, null, function(error) {
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    PostgreSQLAdapter.prototype._getModelID = function(data) {
      return Number(data.id);
    };

    _processSaveError = function(tableName, error, callback) {
      var column, key;

      if (error.code === '42P01') {
        error = new Error('table does not exist');
      } else if (error.code === '23505') {
        column = '';
        key = error.message.match(/unique constraint \"(.*)\"/);
        if (key != null) {
          column = key[1];
          key = column.match(new RegExp("" + tableName + "_([^']*)_key"));
          if (key != null) {
            column = key[1];
          }
          column = ' ' + column;
        }
        error = new Error('duplicated' + column);
      } else {
        error = PostgreSQLAdapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    PostgreSQLAdapter.prototype._buildUpdateSetOfColumn = function(property, data, values, fields, places, insert) {
      var dbname;

      dbname = property._dbname;
      values.push(data[dbname]);
      if (insert) {
        fields.push(dbname);
        return places.push('$' + values.length);
      } else {
        return fields.push(dbname + '=$' + values.length);
      }
    };

    PostgreSQLAdapter.prototype._buildUpdateSet = function(model, data, values, insert) {
      var column, fields, places, property, schema;

      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    };

    PostgreSQLAdapter.prototype._buildPartialUpdateSet = function(model, data, values) {
      var column, fields, places, property, schema, value;

      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    };

    PostgreSQLAdapter.prototype.create = function(model, data, callback) {
      var fields, places, sql, tableName, values, _ref;

      tableName = this._connection.models[model].tableName;
      values = [];
      _ref = this._buildUpdateSet(model, data, values, true), fields = _ref[0], places = _ref[1];
      sql = "INSERT INTO " + tableName + " (" + fields + ") VALUES (" + places + ") RETURNING id";
      return this._query(sql, values, function(error, result) {
        var rows;

        rows = result != null ? result.rows : void 0;
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        if ((rows != null ? rows.length : void 0) === 1 && (rows[0].id != null)) {
          return callback(null, rows[0].id);
        } else {
          return callback(new Error('unexpected rows'));
        }
      });
    };

    PostgreSQLAdapter.prototype.createBulk = function(model, data, callback) {
      var fields, places, sql, tableName, values,
        _this = this;

      tableName = this._connection.models[model].tableName;
      values = [];
      fields = void 0;
      places = [];
      data.forEach(function(item) {
        var places_sub, _ref;

        _ref = _this._buildUpdateSet(model, item, values, true), fields = _ref[0], places_sub = _ref[1];
        return places.push('(' + places_sub + ')');
      });
      sql = "INSERT INTO " + tableName + " (" + fields + ") VALUES " + (places.join(',')) + " RETURNING id";
      return this._query(sql, values, function(error, result) {
        var ids;

        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        ids = result != null ? result.rows.map(function(row) {
          return row.id;
        }) : void 0;
        if (ids.length === data.length) {
          return callback(null, ids);
        } else {
          return callback(new Error('unexpected rows'));
        }
      });
    };

    PostgreSQLAdapter.prototype.update = function(model, data, callback) {
      var fields, sql, tableName, values;

      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildUpdateSet(model, data, values)[0];
      values.push(data.id);
      sql = "UPDATE " + tableName + " SET " + fields + " WHERE id=$" + values.length;
      return this._query(sql, values, function(error) {
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        return callback(null);
      });
    };

    PostgreSQLAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var fields, sql, tableName, values;

      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildPartialUpdateSet(model, data, values)[0];
      sql = "UPDATE " + tableName + " SET " + fields;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      return this._query(sql, values, function(error, result) {
        if (error) {
          return _processSaveError(tableName, error, callback);
        }
        return callback(null, result.rowCount);
      });
    };

    PostgreSQLAdapter.prototype.findById = function(model, id, options, callback) {
      var select, tableName,
        _this = this;

      select = this._buildSelect(this._connection.models[model], options.select);
      tableName = this._connection.models[model].tableName;
      return this._query("SELECT " + select + " FROM " + tableName + " WHERE id=$1 LIMIT 1", [id], function(error, result) {
        var rows;

        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if ((rows != null ? rows.length : void 0) === 1) {
          if (options.lean) {
            return callback(null, _this._refineRawInstance(model, rows[0], options.select));
          } else {
            return callback(null, _this._convertToModelInstance(model, rows[0], options.select));
          }
        } else if ((rows != null ? rows.length : void 0) > 1) {
          return callback(new Error('unknown error'));
        } else {
          return callback(new Error('not found'));
        }
      });
    };

    PostgreSQLAdapter.prototype.find = function(model, conditions, options, callback) {
      var orders, params, select, sql, tableName,
        _this = this;

      if (options.group_by || options.group_fields) {
        select = this._buildGroupFields(options.group_by, options.group_fields);
      } else {
        select = this._buildSelect(this._connection.models[model], options.select);
      }
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "SELECT " + select + " FROM " + tableName;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
      }
      if (options.conditions_of_group.length > 0) {
        try {
          sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      if ((options != null ? options.orders.length : void 0) > 0) {
        orders = options.orders.map(function(order) {
          if (order[0] === '-') {
            return order.slice(1) + ' DESC';
          } else {
            return order + ' ASC';
          }
        });
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
        if ((options != null ? options.skip : void 0) != null) {
          sql += ' OFFSET ' + options.skip;
        }
      } else if ((options != null ? options.skip : void 0) != null) {
        sql += ' LIMIT ALL OFFSET ' + options.skip;
      }
      return this._query(sql, params, function(error, result) {
        var rows;

        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if (options.group_fields) {
          return callback(null, rows.map(function(record) {
            return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
          }));
        } else {
          if (options.lean) {
            return callback(null, rows.map(function(record) {
              return _this._refineRawInstance(model, record, options.select);
            }));
          } else {
            return callback(null, rows.map(function(record) {
              return _this._convertToModelInstance(model, record, options.select);
            }));
          }
        }
      });
    };

    PostgreSQLAdapter.prototype.count = function(model, conditions, callback) {
      var params, sql, tableName,
        _this = this;

      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "SELECT COUNT(*) AS count FROM " + tableName;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      return this._query(sql, params, function(error, result) {
        var rows;

        rows = result != null ? result.rows : void 0;
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        if ((rows != null ? rows.length : void 0) !== 1) {
          return callback(error('unknown error'));
        }
        return callback(null, Number(rows[0].count));
      });
    };

    PostgreSQLAdapter.prototype["delete"] = function(model, conditions, callback) {
      var params, sql, tableName;

      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "DELETE FROM " + tableName;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      return this._query(sql, params, function(error, result) {
        if (error && error.code === '23503') {
          return callback(new Error('rejected'));
        }
        if (error || (result == null)) {
          return callback(PostgreSQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.rowCount);
      });
    };

    PostgreSQLAdapter.prototype.connect = function(settings, callback) {
      var _this = this;

      return pg.connect({
        host: settings.host,
        port: settings.port,
        user: settings.user,
        password: settings.password,
        database: settings.database
      }, function(error, client, done) {
        if ((error != null ? error.code : void 0) === '3D000') {
          return callback(new Error('database does not exist'));
        }
        if (error) {
          return callback(PostgreSQLAdapter.wrapError('failed to connect', error));
        }
        _this._client = client;
        _this._client_done = done;
        return callback(null);
      });
    };

    PostgreSQLAdapter.prototype.close = function() {
      if (this._client_done) {
        this._client_done();
        this._client_done = null;
      }
      return this._client = null;
    };

    return PostgreSQLAdapter;

  })(SQLAdapterBase);

  module.exports = function(connection) {
    return new PostgreSQLAdapter(connection);
  };

}).call(this);
