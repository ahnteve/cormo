// Generated by CoffeeScript 1.9.3
(function() {
  var SQLAdapterBase, SQLite3Adapter, _, _propertyToSQL, _typeToSQL, async, e, sqlite3, stream, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  try {
    sqlite3 = require('sqlite3');
  } catch (_error) {
    e = _error;
    console.log('Install sqlite3 module to use this adapter');
    process.exit(1);
  }

  SQLAdapterBase = require('./sql_base');

  types = require('../types');

  async = require('async');

  _ = require('lodash');

  stream = require('stream');

  _typeToSQL = function(property) {
    if (property.array) {
      return 'TEXT';
    }
    switch (property.type_class) {
      case types.String:
        return 'TEXT';
      case types.Number:
        return 'DOUBLE';
      case types.Boolean:
        return 'TINYINT';
      case types.Integer:
        return 'INT';
      case types.Date:
        return 'REAL';
      case types.Object:
        return 'TEXT';
    }
  };

  _propertyToSQL = function(property) {
    var type;
    type = _typeToSQL(property);
    if (type) {
      if (property.required) {
        type += ' NOT NULL';
      } else {
        type += ' NULL';
      }
      if (property.unique) {
        type += ' UNIQUE';
      }
      return type;
    }
  };

  SQLite3Adapter = (function(superClass) {
    var _processSaveError;

    extend(SQLite3Adapter, superClass);

    SQLite3Adapter.prototype.key_type = types.Integer;

    SQLite3Adapter.prototype.native_integrity = true;

    SQLite3Adapter.prototype._regexp_op = null;

    SQLite3Adapter.prototype._false_value = '0';

    function SQLite3Adapter(connection) {
      this._connection = connection;
    }

    SQLite3Adapter.prototype._query = function(method, sql, data, callback) {
      return this._client[method].apply(this._client, [].slice.call(arguments, 1));
    };

    SQLite3Adapter.prototype._createTable = function(model, callback) {
      var column, column_sql, integrity, j, len, model_class, property, ref, ref1, sql, tableName;
      model_class = this._connection.models[model];
      tableName = model_class.tableName;
      sql = [];
      sql.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
      ref = model_class._schema;
      for (column in ref) {
        property = ref[column];
        column_sql = _propertyToSQL(property);
        if (column_sql) {
          sql.push("\"" + property._dbname + "\" " + column_sql);
        }
      }
      ref1 = model_class._integrities;
      for (j = 0, len = ref1.length; j < len; j++) {
        integrity = ref1[j];
        if (integrity.type === 'child_nullify') {
          sql.push("FOREIGN KEY (\"" + integrity.column + "\") REFERENCES \"" + integrity.parent.tableName + "\"(id) ON DELETE SET NULL");
        } else if (integrity.type === 'child_restrict') {
          sql.push("FOREIGN KEY (\"" + integrity.column + "\") REFERENCES \"" + integrity.parent.tableName + "\"(id) ON DELETE RESTRICT");
        } else if (integrity.type === 'child_delete') {
          sql.push("FOREIGN KEY (\"" + integrity.column + "\") REFERENCES \"" + integrity.parent.tableName + "\"(id) ON DELETE CASCADE");
        }
      }
      sql = "CREATE TABLE \"" + tableName + "\" ( " + (sql.join(',')) + " )";
      return this._query('run', sql, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(SQLite3Adapter.wrapError('unknown error', error));
          }
          return async.forEach(model_class._indexes, function(index, callback) {
            var columns, order, ref2, unique;
            columns = [];
            ref2 = index.columns;
            for (column in ref2) {
              order = ref2[column];
              columns.push("\"" + column + "\" " + (order === -1 ? 'DESC' : 'ASC'));
            }
            unique = index.options.unique ? 'UNIQUE ' : '';
            sql = "CREATE " + unique + "INDEX \"" + index.options.name + "\" ON \"" + tableName + "\" (" + (columns.join(',')) + ")";
            return _this._query('run', sql, callback);
          }, function(error) {
            if (error) {
              return callback(SQLite3Adapter.wrapError('unknown error', error));
            }
            return callback(null);
          });
        };
      })(this));
    };

    SQLite3Adapter.prototype.applySchema = function(model, callback) {
      var tableName;
      tableName = this._connection.models[model].tableName;
      return this._query('all', "SELECT name FROM sqlite_master WHERE type='table' AND name='" + tableName + "'", (function(_this) {
        return function(error, result) {
          if ((result != null ? result.length : void 0) !== 1) {
            return _this._createTable(model, callback);
          } else {
            return callback(null);
          }
        };
      })(this));
    };

    SQLite3Adapter.prototype.drop = function(model, callback) {
      var tableName;
      tableName = this._connection.models[model].tableName;
      return this._query('run', "DROP TABLE IF EXISTS \"" + tableName + "\"", function(error) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    SQLite3Adapter.prototype._getModelID = function(data) {
      return Number(data.id);
    };

    SQLite3Adapter.prototype.valueToModel = function(value, property) {
      if (property.type_class === types.Object || property.array) {
        return JSON.parse(value);
      } else if (property.type_class === types.Date) {
        return new Date(value);
      } else if (property.type_class === types.Boolean) {
        return value !== 0;
      } else {
        return value;
      }
    };

    _processSaveError = function(error, callback) {
      if (/no such table/.test(error.message)) {
        error = new Error('table does not exist');
      } else if (error.code === 'SQLITE_CONSTRAINT') {
        error = new Error('duplicated');
      } else {
        error = SQLite3Adapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    SQLite3Adapter.prototype._buildUpdateSetOfColumn = function(property, data, values, fields, places, insert) {
      var dbname, value;
      dbname = property._dbname;
      value = data[dbname];
      if (value != null ? value.$inc : void 0) {
        values.push(value.$inc);
        return fields.push("\"" + dbname + "\"=\"" + dbname + "\"+?");
      } else {
        if (property.type_class === types.Date) {
          values.push(value != null ? value.getTime() : void 0);
        } else {
          values.push(value);
        }
        if (insert) {
          fields.push("\"" + dbname + "\"");
          return places.push('?');
        } else {
          return fields.push("\"" + dbname + "\"=?");
        }
      }
    };

    SQLite3Adapter.prototype._buildUpdateSet = function(model, data, values, insert) {
      var column, fields, places, property, schema;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    };

    SQLite3Adapter.prototype._buildPartialUpdateSet = function(model, data, values) {
      var column, fields, places, property, schema, value;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    };

    SQLite3Adapter.prototype.create = function(model, data, callback) {
      var fields, places, ref, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      ref = this._buildUpdateSet(model, data, values, true), fields = ref[0], places = ref[1];
      sql = "INSERT INTO \"" + tableName + "\" (" + fields + ") VALUES (" + places + ")";
      return this._query('run', sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null, this.lastID);
      });
    };

    SQLite3Adapter.prototype.createBulk = function(model, data, callback) {
      var fields, places, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = void 0;
      places = [];
      data.forEach((function(_this) {
        return function(item) {
          var places_sub, ref;
          ref = _this._buildUpdateSet(model, item, values, true), fields = ref[0], places_sub = ref[1];
          return places.push('(' + places_sub + ')');
        };
      })(this));
      sql = "INSERT INTO \"" + tableName + "\" (" + fields + ") VALUES " + (places.join(','));
      return this._query('run', sql, values, function(error) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        if (id = this.lastID) {
          id = id - data.length + 1;
          return callback(null, data.map(function(item, i) {
            return id + i;
          }));
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    SQLite3Adapter.prototype.update = function(model, data, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildUpdateSet(model, data, values)[0];
      values.push(data.id);
      sql = "UPDATE \"" + tableName + "\" SET " + fields + " WHERE id=?";
      return this._query('run', sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    SQLite3Adapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var fields, sql, tableName, values;
      tableName = this._connection.models[model].tableName;
      values = [];
      fields = this._buildPartialUpdateSet(model, data, values)[0];
      sql = "UPDATE \"" + tableName + "\" SET " + fields;
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      return this._query('run', sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null, this.changes);
      });
    };

    SQLite3Adapter.prototype.findById = function(model, id, options, callback) {
      var select, sql, tableName;
      select = this._buildSelect(this._connection.models[model], options.select);
      tableName = this._connection.models[model].tableName;
      sql = "SELECT " + select + " FROM \"" + tableName + "\" WHERE id=? LIMIT 1";
      if (options.explain) {
        return this._query('all', "EXPLAIN QUERY PLAN " + sql, id, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query('all', sql, id, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(SQLite3Adapter.wrapError('unknown error', error));
          }
          if ((result != null ? result.length : void 0) === 1) {
            if (options.lean) {
              return callback(null, _this._refineRawInstance(model, result[0], options.select, options.select_raw));
            } else {
              return callback(null, _this._convertToModelInstance(model, result[0], options.select, options.select_raw));
            }
          } else if ((result != null ? result.length : void 0) > 1) {
            return callback(new Error('unknown error'));
          } else {
            return callback(new Error('not found'));
          }
        };
      })(this));
    };

    SQLite3Adapter.prototype._buildSqlForFind = function(model, conditions, options) {
      var orders, params, select, sql, tableName;
      if (options.group_by || options.group_fields) {
        select = this._buildGroupFields(options.group_by, options.group_fields);
      } else {
        select = this._buildSelect(this._connection.models[model], options.select);
      }
      tableName = this._connection.models[model].tableName;
      params = [];
      sql = "SELECT " + select + " FROM \"" + tableName + "\"";
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
      }
      if (options.conditions_of_group.length > 0) {
        sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
      }
      if ((options != null ? options.orders.length : void 0) > 0) {
        orders = options.orders.map(function(order) {
          if (order[0] === '-') {
            return "\"" + order.slice(1) + "\" DESC";
          } else {
            return "\"" + order + "\" ASC";
          }
        });
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
        if ((options != null ? options.skip : void 0) != null) {
          sql += ' OFFSET ' + options.skip;
        }
      } else if ((options != null ? options.skip : void 0) != null) {
        sql += ' LIMIT 2147483647 OFFSET ' + options.skip;
      }
      return [sql, params];
    };

    SQLite3Adapter.prototype.find = function(model, conditions, options, callback) {
      var params, ref, sql;
      try {
        ref = this._buildSqlForFind(model, conditions, options), sql = ref[0], params = ref[1];
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      if (options.explain) {
        return this._query('all', "EXPLAIN QUERY PLAN " + sql, params, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._query('all', sql, params, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(SQLite3Adapter.wrapError('unknown error', error));
          }
          if (options.group_fields) {
            return callback(null, result.map(function(record) {
              return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
            }));
          } else {
            if (options.lean) {
              return callback(null, result.map(function(record) {
                return _this._refineRawInstance(model, record, options.select, options.select_raw);
              }));
            } else {
              return callback(null, result.map(function(record) {
                return _this._convertToModelInstance(model, record, options.select, options.select_raw);
              }));
            }
          }
        };
      })(this));
    };

    SQLite3Adapter.prototype.stream = function(model, conditions, options) {
      var params, readable, ref, sql;
      try {
        ref = this._buildSqlForFind(model, conditions, options), sql = ref[0], params = ref[1];
      } catch (_error) {
        e = _error;
        readable = new stream.Readable({
          objectMode: true
        });
        readable._read = function() {
          return readable.emit('error', e);
        };
        return readable;
      }
      readable = new stream.Readable({
        objectMode: true
      });
      readable._read = function() {};
      this._client.each(sql, params, (function(_this) {
        return function(error, record) {
          if (error) {
            return readable.emit('error', error);
          }
          return readable.push(_this._convertToModelInstance(model, record, options.select, options.select_raw));
        };
      })(this), function() {
        return readable.push(null);
      });
      return readable;
    };

    SQLite3Adapter.prototype.count = function(model, conditions, options, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "SELECT COUNT(*) AS count FROM \"" + tableName + "\"";
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      if (options.group_by) {
        sql += ' GROUP BY ' + options.group_by.join(',');
        if (options.conditions_of_group.length > 0) {
          try {
            sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
          } catch (_error) {
            e = _error;
            return callback(e);
          }
        }
        sql = "SELECT COUNT(*) AS count FROM (" + sql + ")";
      }
      return this._query('all', sql, params, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(SQLite3Adapter.wrapError('unknown error', error));
          }
          if ((result != null ? result.length : void 0) !== 1) {
            return callback(new Error('unknown error'));
          }
          return callback(null, Number(result[0].count));
        };
      })(this));
    };

    SQLite3Adapter.prototype["delete"] = function(model, conditions, callback) {
      var params, sql, tableName;
      params = [];
      tableName = this._connection.models[model].tableName;
      sql = "DELETE FROM \"" + tableName + "\"";
      if (conditions.length > 0) {
        try {
          sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
      return this._query('run', sql, params, function(error) {
        if (error && error.code === 'SQLITE_CONSTRAINT') {
          return callback(new Error('rejected'));
        }
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null, this.changes);
      });
    };

    SQLite3Adapter.prototype.connect = function(settings, callback) {
      var client;
      return client = new sqlite3.Database(settings.database, (function(_this) {
        return function(error) {
          if (error) {
            return callback(SQLite3Adapter.wrapError('failed to open', error));
          }
          _this._client = client;
          return _this._query('run', 'PRAGMA foreign_keys=ON', function(error) {
            return callback(null);
          });
        };
      })(this));
    };

    SQLite3Adapter.prototype.close = function() {
      if (this._client) {
        this._client.close();
      }
      return this._client = null;
    };

    return SQLite3Adapter;

  })(SQLAdapterBase);

  module.exports = function(connection) {
    return new SQLite3Adapter(connection);
  };

}).call(this);
