// Generated by CoffeeScript 1.4.0
(function() {
  var AdapterBase, SQLite3Adapter, async, sqlite3, tableize, types, _buildWhere, _propertyToSQL, _typeToSQL,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    sqlite3 = require('sqlite3');
  } catch (e) {
    console.log('Install sqlite3 module to use this adapter');
    process.exit(1);
  }

  AdapterBase = require('./base');

  types = require('../types');

  tableize = require('../inflector').tableize;

  async = require('async');

  _typeToSQL = function(property) {
    switch (property.type) {
      case types.String:
        return 'VARCHAR(255)';
      case types.Number:
        return 'DOUBLE';
      case types.Integer:
        return 'INT';
      case types.Date:
        return 'REAL';
    }
  };

  _propertyToSQL = function(property) {
    var type;
    type = _typeToSQL(property);
    if (type) {
      if (property.required) {
        type += ' NOT NULL';
      } else {
        type += ' NULL';
      }
      if (property.unique) {
        type += ' UNIQUE';
      }
      return type;
    }
  };

  _buildWhere = function(conditions, params, conjunction) {
    var key, keys, op, sub_key, subs, value, values;
    if (conjunction == null) {
      conjunction = 'AND';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(condition, params);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return '';
      }
      if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(conditions[key], params, 'AND');
            case '$or':
              return _buildWhere(conditions[key], params, 'OR');
          }
        } else {
          value = conditions[key];
          op = '=';
          if (Array.isArray(value)) {
            values = value.map(function(value) {
              params.push(value);
              return '?';
            });
            return "" + key + " IN (" + (values.join(',')) + ")";
          } else if (typeof value === 'object' && (keys = Object.keys(value)).length === 1) {
            sub_key = keys[0];
            if (sub_key === '$in') {
              values = value[sub_key];
              values = values.map(function(value) {
                params.push(value);
                return '?';
              });
              return "" + key + " IN (" + (values.join(',')) + ")";
            }
            switch (sub_key) {
              case '$gt':
                op = '>';
                value = value[sub_key];
                break;
              case '$lt':
                op = '<';
                value = value[sub_key];
                break;
              case '$gte':
                op = '>=';
                value = value[sub_key];
                break;
              case '$lte':
                op = '<=';
                value = value[sub_key];
                break;
              case '$contains':
                op = ' LIKE ';
                value = '%' + value[sub_key] + '%';
            }
          }
          params.push(value);
          return key + op + '?';
        }
      } else {
        subs = keys.map(function(key) {
          var obj;
          obj = {};
          obj[key] = conditions[key];
          return _buildWhere(obj, params);
        });
      }
    } else {
      return '';
    }
    return '(' + subs.join(' ' + conjunction + ' ') + ')';
  };

  /*
  # Adapter for SQLite3
  */


  SQLite3Adapter = (function(_super) {
    var _processSaveError;

    __extends(SQLite3Adapter, _super);

    SQLite3Adapter.prototype.key_type = types.Integer;

    /*
      # Creates a SQLite3 adapter
    */


    function SQLite3Adapter(connection) {
      this._connection = connection;
    }

    SQLite3Adapter.prototype._query = function(method, sql, data, callback) {
      return this._client[method].apply(this._client, [].slice.call(arguments, 1));
    };

    SQLite3Adapter.prototype._createTable = function(model, callback) {
      var column, column_sql, property, sql, table, _ref;
      table = tableize(model);
      sql = [];
      sql.push('id INTEGER PRIMARY KEY AUTOINCREMENT');
      _ref = this._connection.models[model]._schema;
      for (column in _ref) {
        property = _ref[column];
        column_sql = _propertyToSQL(property);
        if (column_sql) {
          sql.push(column + ' ' + column_sql);
        }
      }
      sql = "CREATE TABLE " + table + " ( " + (sql.join(',')) + " )";
      return this._query('run', sql, function(error, result) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    SQLite3Adapter.prototype._applySchema = function(model, callback) {
      return this._createTable(model, callback);
    };

    /*
      # Creates or alters tables reflecting schemas
      # @param {Function} callback
      # @param {Error} callback.error
      # @see Connection.applySchemas
    */


    SQLite3Adapter.prototype.applySchemas = function(callback) {
      var _this = this;
      return async.forEach(Object.keys(this._connection.models), function(model, callback) {
        return _this._applySchema(model, callback);
      }, function(error) {
        return callback(error);
      });
    };

    /*
      # Drops a model from the database
      # @param {String} model
      # @param {Function} callback
      # @param {Error} callback.error
      # @see Model.drop
    */


    SQLite3Adapter.prototype.drop = function(model, callback) {
      var table;
      table = tableize(model);
      return this._query('run', "DROP TABLE IF EXISTS " + table, function(error) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    _processSaveError = function(error, callback) {
      if (/no such table/.test(error.message)) {
        error = new Error('table does not exist');
      } else if (error.code === 'SQLITE_CONSTRAINT') {
        error = new Error('duplicated');
      } else {
        error = SQLite3Adapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    /*
      # Creates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {RecordID} callback.id
    */


    SQLite3Adapter.prototype.create = function(model, data, callback) {
      var fields, places, schema, sql, values;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      values = [];
      Object.keys(data).forEach(function(field) {
        var _ref;
        fields.push(field);
        if (schema[field].type === types.Date) {
          places.push('?');
          return values.push((_ref = data[field]) != null ? _ref.getTime() : void 0);
        } else {
          places.push('?');
          return values.push(data[field]);
        }
      });
      sql = "INSERT INTO " + (tableize(model)) + " (" + (fields.join(',')) + ") VALUES (" + (places.join(',')) + ")";
      return this._query('run', sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null, this.lastID);
      });
    };

    /*
      # Updates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
    */


    SQLite3Adapter.prototype.update = function(model, data, callback) {
      var fields, schema, sql, values;
      schema = this._connection.models[model]._schema;
      fields = [];
      values = [];
      Object.keys(data).forEach(function(field) {
        var _ref;
        if (field === 'id') {
          return;
        }
        if (schema[field].type === types.Date) {
          fields.push(field + '=?');
          return values.push((_ref = data[field]) != null ? _ref.getTime() : void 0);
        } else {
          fields.push(field + '=?');
          return values.push(data[field]);
        }
      });
      sql = "UPDATE " + (tableize(model)) + " SET " + (fields.join(',')) + " WHERE id=?";
      values.push(data.id);
      return this._query('run', sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    SQLite3Adapter.prototype._convertToModelInstance = function(model, data) {
      var column, modelClass, property, record, _ref;
      modelClass = this._connection.models[model];
      record = new modelClass();
      Object.defineProperty(record, 'id', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: Number(data.id)
      });
      _ref = modelClass._schema;
      for (column in _ref) {
        property = _ref[column];
        if (!(data[column] != null)) {
          continue;
        }
        if (property.type === types.Date) {
          record[column] = new Date(data[column]);
        } else {
          record[column] = data[column];
        }
      }
      return record;
    };

    /*
      # Finds a record by id
      # @param {String} model
      # @param {RecordID} id
      # @param {Object} options
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Model} callback.record
      # @throws Error('not found')
    */


    SQLite3Adapter.prototype.findById = function(model, id, options, callback) {
      var selects, table,
        _this = this;
      if (options.select) {
        selects = 'id,' + options.select.join(',');
      } else {
        selects = '*';
      }
      table = tableize(model);
      return this._query('all', "SELECT " + selects + " FROM " + table + " WHERE id=? LIMIT 1", id, function(error, result) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        if ((result != null ? result.length : void 0) === 1) {
          return callback(null, _this._convertToModelInstance(model, result[0]));
        } else if ((result != null ? result.length : void 0) > 1) {
          return callback(new Error('unknown error'));
        } else {
          return callback(new Error('not found'));
        }
      });
    };

    /*
      # Finds records
      # @param {String} model
      # @param {Object} conditions
      # @param {Object} options
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Array<Model>} callback.records
    */


    SQLite3Adapter.prototype.find = function(model, conditions, options, callback) {
      var params, selects, sql,
        _this = this;
      if (options.select) {
        selects = 'id,' + options.select.join(',');
      } else {
        selects = '*';
      }
      params = [];
      sql = "SELECT " + selects + " FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + _buildWhere(conditions, params);
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
      }
      return this._query('all', sql, params, function(error, result) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null, result.map(function(record) {
          return _this._convertToModelInstance(model, record);
        }));
      });
    };

    /*
      # Counts records
      # @param {String} model
      # @param {Object} conditions
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Number} callback.count
    */


    SQLite3Adapter.prototype.count = function(model, conditions, callback) {
      var params, sql,
        _this = this;
      params = [];
      sql = "SELECT COUNT(*) AS count FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + _buildWhere(conditions, params);
      }
      return this._query('all', sql, params, function(error, result) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        if ((result != null ? result.length : void 0) !== 1) {
          return callback(error('unknown error'));
        }
        return callback(null, Number(result[0].count));
      });
    };

    /*
      # Deletes records from the database
      # @param {String} model
      # @param {Object} conditions
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Number} callback.count
    */


    SQLite3Adapter.prototype["delete"] = function(model, conditions, callback) {
      var params, sql;
      params = [];
      sql = "DELETE FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + _buildWhere(conditions, params);
      }
      return this._query('run', sql, params, function(error) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('unknown error', error));
        }
        return callback(null, this.changes);
      });
    };

    /*
      # Connects to the database
      # @param {Object} settings
      # @param {String} settings.database
      # @param {Function} callback
      # @param {Error} callback.error
    */


    SQLite3Adapter.prototype.connect = function(settings, callback) {
      var client,
        _this = this;
      return client = new sqlite3.Database(settings.database, function(error) {
        if (error) {
          return callback(SQLite3Adapter.wrapError('failed to open', error));
        }
        _this._client = client;
        return callback(null);
      });
    };

    return SQLite3Adapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new SQLite3Adapter(connection);
  };

}).call(this);
