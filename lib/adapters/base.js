// Generated by CoffeeScript 1.7.1
(function() {
  var AdapterBase, async, types, util;

  async = require('async');

  types = require('../types');

  util = require('../util');

  AdapterBase = (function() {
    function AdapterBase() {}

    AdapterBase.wrapError = function(msg, cause) {
      var error;
      error = new Error(msg);
      error.cause = cause;
      return error;
    };

    AdapterBase.prototype.applySchema = function(model, callback) {
      return callback(null);
    };

    AdapterBase.prototype.drop = function(model, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.idToDB = function(value) {
      return value;
    };

    AdapterBase.prototype.valueToDB = function(value, column, property) {
      if (property.type === types.Object || property.array) {
        return JSON.stringify(value);
      } else if (value != null) {
        return value;
      } else {
        return null;
      }
    };

    AdapterBase.prototype._getModelID = function(data) {
      return data.id;
    };

    AdapterBase.prototype.valueToModel = function(value, property) {
      if (property.type === types.Object || property.array) {
        return JSON.parse(value);
      } else {
        return value;
      }
    };

    AdapterBase.prototype._refineRawInstance = function(model, data, selected_columns) {
      var column, id, instance, parts, property, schema, support_nested, value, _i, _len;
      schema = this._connection.models[model]._schema;
      if (!selected_columns) {
        selected_columns = Object.keys(schema);
      }
      support_nested = this.support_nested;
      id = this._getModelID(data);
      instance = {};
      for (_i = 0, _len = selected_columns.length; _i < _len; _i++) {
        column = selected_columns[_i];
        property = schema[column];
        parts = property._parts;
        value = support_nested ? util.getPropertyOfPath(data, parts) : data[property._dbname];
        if (value != null) {
          value = this.valueToModel(value, property);
        } else {
          value = null;
        }
        util.setPropertyOfPath(instance, parts, value);
      }
      Object.defineProperty(instance, 'id', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: id
      });
      return instance;
    };

    AdapterBase.prototype._convertToModelInstance = function(model, data, selected_columns) {
      var id, modelClass;
      id = this._getModelID(data);
      modelClass = this._connection.models[model];
      return new modelClass(data, id, selected_columns);
    };

    AdapterBase.prototype._convertToGroupInstance = function(model, data, group_by, group_fields) {
      var expr, field, instance, op, property, schema, _i, _len;
      instance = {};
      if (group_by) {
        schema = this._connection.models[model]._schema;
        for (_i = 0, _len = group_by.length; _i < _len; _i++) {
          field = group_by[_i];
          property = schema[field];
          if (property) {
            instance[field] = this.valueToModel(data[field], property);
          }
        }
      }
      for (field in group_fields) {
        expr = group_fields[field];
        op = Object.keys(expr)[0];
        if (op === '$sum') {
          instance[field] = Number(data[field]);
        }
      }
      return instance;
    };

    AdapterBase.prototype.create = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.createBulk = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype._createBulkDefault = function(model, data, callback) {
      return async.map(data, (function(_this) {
        return function(item, callback) {
          return _this.create(model, item, util.bindDomain(callback));
        };
      })(this), callback);
    };

    AdapterBase.prototype.update = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.updatePartial = function(model, data, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.findById = function(model, id, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.find = function(model, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.count = function(model, conditions, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype["delete"] = function(model, conditions, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.close = function() {};

    return AdapterBase;

  })();

  module.exports = AdapterBase;

  if (process.env.NODE_ENV === 'test') {
    AdapterBase.wrapError = function(msg, cause) {
      return new Error(msg + ' caused by ' + cause.toString());
    };
  }

}).call(this);
