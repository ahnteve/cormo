// Generated by CoffeeScript 1.4.0
(function() {
  var AdapterBase, async, types, _bindDomain;

  async = require('async');

  types = require('../types');

  _bindDomain = function(fn) {
    var d;
    if (d = process.domain) {
      return d.bind(fn);
    } else {
      return fn;
    }
  };

  AdapterBase = (function() {

    function AdapterBase() {}

    AdapterBase.wrapError = function(msg, cause) {
      var error;
      error = new Error(msg);
      error.cause = cause;
      return error;
    };

    AdapterBase.prototype.applySchema = function(model, callback) {
      return callback(null);
    };

    AdapterBase.prototype.drop = function(model, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.idToDB = function(value) {
      return value;
    };

    AdapterBase.prototype.valueToDB = function(value, column, property) {
      if (property.type === types.Object || property.array) {
        return JSON.stringify(value);
      } else if (value != null) {
        return value;
      } else {
        return null;
      }
    };

    AdapterBase.prototype._getModelID = function(data) {
      return data.id;
    };

    AdapterBase.prototype.valueToModel = function(value, column, property) {
      if (property.type === types.Object || property.array) {
        return JSON.parse(value);
      } else {
        return value;
      }
    };

    AdapterBase.prototype._convertToModelInstance = function(model, data, selected_columns) {
      var modelClass;
      modelClass = this._connection.models[model];
      return new modelClass(data, this._getModelID(data), selected_columns);
    };

    AdapterBase.prototype._convertToGroupInstance = function(model, data, group_by, group_fields) {
      var expr, field, instance, op, property, schema, _i, _len;
      instance = {};
      if (group_by) {
        schema = this._connection.models[model]._schema;
        for (_i = 0, _len = group_by.length; _i < _len; _i++) {
          field = group_by[_i];
          property = schema[field];
          if (property) {
            instance[field] = this.valueToModel(data[field], field, property);
          }
        }
      }
      for (field in group_fields) {
        expr = group_fields[field];
        op = Object.keys(expr)[0];
        if (op === '$sum') {
          instance[field] = Number(data[field]);
        }
      }
      return instance;
    };

    AdapterBase.prototype.create = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.createBulk = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype._createBulkDefault = function(model, data, callback) {
      var _this = this;
      return async.map(data, function(item, callback) {
        return _this.create(model, item, _bindDomain(callback));
      }, callback);
    };

    AdapterBase.prototype.update = function(model, data, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.updatePartial = function(model, data, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.findById = function(model, id, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.find = function(model, conditions, options, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype.count = function(model, conditions, callback) {
      return callback(new Error('not implemented'));
    };

    AdapterBase.prototype["delete"] = function(model, conditions, callback) {
      return callback(new Error('not implemented'));
    };

    return AdapterBase;

  })();

  module.exports = AdapterBase;

}).call(this);
