// Generated by CoffeeScript 1.4.0
(function() {
  var AdapterBase, MongoDBAdapter, ObjectID, async, mongodb, tableize, types, _buildWhere,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    mongodb = require('mongodb');
  } catch (error) {
    console.log('Install mongodb module to use this adapter');
    process.exit(1);
  }

  ObjectID = mongodb.ObjectID;

  AdapterBase = require('./base');

  types = require('../types');

  tableize = require('../inflector').tableize;

  async = require('async');

  _buildWhere = function(schema, conditions, conjunction) {
    var is_objectid, key, keys, obj, sub_key, subs, value, _ref, _ref1;
    if (conjunction == null) {
      conjunction = '$and';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(schema, condition);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return;
      } else if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(schema, conditions[key], '$and');
            case '$or':
              return _buildWhere(schema, conditions[key], '$or');
          }
          return;
        } else {
          is_objectid = key === 'id' || schema[key].type === 'objectid';
          value = conditions[key];
          if (Array.isArray(value)) {
            if (is_objectid) {
              try {
                value = value.map(function(v) {
                  return new ObjectID(v);
                });
              } catch (e) {
                throw new Error("'" + key + "' is not a valid id");
              }
            }
            value = {
              $in: value
            };
          } else if (typeof value === 'object' && (keys = Object.keys(value)).length === 1) {
            sub_key = keys[0];
            switch (sub_key) {
              case '$gt':
              case '$lt':
              case '$gte':
              case '$lte':
                obj = {};
                obj[key] = {};
                if (((_ref = schema[key]) != null ? _ref.type : void 0) === types.Date) {
                  obj[key][sub_key] = new Date(value[sub_key]);
                } else {
                  obj[key][sub_key] = value[sub_key];
                }
                return obj;
              case '$contains':
                value = new RegExp(value[sub_key], 'i');
                break;
              case '$in':
                if (is_objectid) {
                  try {
                    value[sub_key] = value[sub_key].map(function(v) {
                      return new ObjectID(v);
                    });
                  } catch (e) {
                    throw new Error("'" + key + "' is not a valid id");
                  }
                }
            }
          } else if (is_objectid) {
            try {
              value = new ObjectID(value);
            } catch (e) {
              throw new Error("'" + key + "' is not a valid id");
            }
          }
          if (key === 'id') {
            key = '_id';
          }
          obj = {};
          if (((_ref1 = schema[key]) != null ? _ref1.type : void 0) === types.Date) {
            obj[key] = new Date(value);
          } else {
            obj[key] = value;
          }
          return obj;
        }
      } else {
        subs = keys.map(function(key) {
          obj = {};
          obj[key] = conditions[key];
          return _buildWhere(schema, obj);
        });
      }
    } else {
      return;
    }
    if (subs.length === 0) {
      return;
    }
    if (subs.length === 1) {
      return subs[0];
    }
    obj = {};
    obj[conjunction] = subs;
    return obj;
  };

  MongoDBAdapter = (function(_super) {

    __extends(MongoDBAdapter, _super);

    MongoDBAdapter.prototype.key_type = types.String;

    MongoDBAdapter.prototype.key_type_internal = 'objectid';

    MongoDBAdapter.prototype.support_geopoint = true;

    MongoDBAdapter.prototype.support_nested = true;

    function MongoDBAdapter(connection) {
      this._connection = connection;
      this._collections = {};
    }

    MongoDBAdapter.prototype._collection = function(name) {
      name = tableize(name);
      if (!this._collections[name]) {
        return this._collections[name] = new mongodb.Collection(this._client, name);
      } else {
        return this._collections[name];
      }
    };

    MongoDBAdapter.prototype.applySchema = function(model, callback) {
      var collection, column, indexes, obj, property, _ref;
      collection = this._collection(model);
      indexes = [];
      _ref = this._connection.models[model]._schema;
      for (column in _ref) {
        property = _ref[column];
        if (property.unique) {
          indexes.push([
            column, {
              safe: true,
              unique: true,
              sparse: true
            }
          ]);
        }
        if (property.type === types.GeoPoint) {
          obj = {};
          obj[column] = '2d';
          indexes.push([obj]);
        }
      }
      return async.forEach(indexes, function(index, callback) {
        return collection.ensureIndex(index[0], index[1], function(error) {
          return callback(error);
        });
      }, function(error) {
        return callback(error);
      });
    };

    MongoDBAdapter.prototype.drop = function(model, callback) {
      var name;
      name = tableize(model);
      delete this._collections[name];
      return this._client.dropCollection(name, function(error) {
        if (error && error.errmsg !== 'ns not found') {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.idToDB = function(value) {
      try {
        return new ObjectID(value);
      } catch (e) {
        return callback(new Error("'id' is not a valid ID"));
      }
    };

    MongoDBAdapter.prototype.valueToDB = function(value, column, property) {
      if (!(value != null)) {
        return;
      }
      if (column === 'id' || property.type === 'objectid') {
        try {
          return new ObjectID(value);
        } catch (e) {
          callback(new Error("'" + column + "' is not a valid ID"));
        }
      }
      return value;
    };

    MongoDBAdapter.prototype._getModelID = function(data) {
      return data._id.toString();
    };

    MongoDBAdapter.prototype.valueToModel = function(value, column, property) {
      if (property.type === 'objectid') {
        return value.toString();
      } else {
        return value;
      }
    };

    MongoDBAdapter.prototype.create = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var id, key, _ref;
        if ((error != null ? error.code : void 0) === 11000) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        id = result != null ? (_ref = result[0]) != null ? _ref._id.toString() : void 0 : void 0;
        if (id) {
          delete data._id;
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MongoDBAdapter.prototype.createBulk = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var ids, key;
        if ((error != null ? error.code : void 0) === 11000) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        error = void 0;
        ids = result.map(function(doc) {
          var id;
          id = doc._id.toString();
          if (id) {
            delete data._id;
          } else {
            error = new Error('unexpected result');
          }
          return id;
        });
        if (error) {
          return callback(error);
        }
        return callback(null, ids);
      });
    };

    MongoDBAdapter.prototype.update = function(model, data, callback) {
      var id;
      id = data.id;
      delete data.id;
      return this._collection(model).update({
        _id: id
      }, data, {
        safe: true
      }, function(error) {
        var key;
        if ((error != null ? error.code : void 0) === 11001) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._buildUpdateOps = function(schema, update_ops, data, path, object) {
      var column, property, value, _results;
      _results = [];
      for (column in object) {
        value = object[column];
        property = schema[path + column];
        if (property) {
          if (value != null) {
            _results.push(update_ops.$set[path + column] = value);
          } else {
            _results.push(update_ops.$unset[path + column] = '');
          }
        } else if (typeof object[column] === 'object') {
          _results.push(this._buildUpdateOps(schema, update_ops, data, path + column + '.', object[column]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MongoDBAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var schema, update_ops;
      schema = this._connection.models[model]._schema;
      try {
        conditions = _buildWhere(schema, conditions);
      } catch (e) {
        return callback(e);
      }
      if (!conditions) {
        conditions = {};
      }
      update_ops = {
        $set: {},
        $unset: {}
      };
      this._buildUpdateOps(schema, update_ops, data, '', data);
      return this._collection(model).update(conditions, update_ops, {
        safe: true,
        multi: true
      }, function(error, count) {
        var key;
        if ((error != null ? error.code : void 0) === 11001) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype.findById = function(model, id, options, callback) {
      var fields,
        _this = this;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        id = new ObjectID(id);
      } catch (e) {
        return callback(new Error('not found'));
      }
      options = {};
      if (fields) {
        options.fields = fields;
      }
      return this._collection(model).findOne({
        _id: id
      }, options, function(error, result) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        if (!result) {
          return callback(new Error('not found'));
        }
        return callback(null, _this._convertToModelInstance(model, result));
      });
    };

    MongoDBAdapter.prototype.find = function(model, conditions, options, callback) {
      var field, fields, obj, orders,
        _this = this;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        obj = {};
        obj[field] = {
          $near: options.near[field]
        };
        if (conditions) {
          conditions = {
            $and: [conditions, obj]
          };
        } else {
          conditions = obj;
        }
      }
      if (options.orders.length > 0) {
        orders = {};
        options.orders.forEach(function(order) {
          if (order[0] === '-') {
            return orders[order.slice(1)] = -1;
          } else {
            return orders[order] = 1;
          }
        });
      }
      options = {
        limit: options.limit
      };
      if (fields) {
        options.fields = fields;
      }
      if (orders) {
        options.sort = orders;
      }
      return this._collection(model).find(conditions, options, function(error, cursor) {
        if (error || !cursor) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return cursor.toArray(function(error, result) {
          if (error || !cursor) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          return callback(null, result.map(function(record) {
            return _this._convertToModelInstance(model, record);
          }));
        });
      });
    };

    MongoDBAdapter.prototype.count = function(model, conditions, callback) {
      var _this = this;
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      return this._collection(model).count(conditions, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype["delete"] = function(model, conditions, callback) {
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      return this._collection(model).remove(conditions, {
        safe: true
      }, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype.connect = function(settings, callback) {
      var db, server,
        _this = this;
      server = new mongodb.Server(settings.host || 'localhost', settings.port || 27017, {});
      db = new mongodb.Db(settings.database, server, {
        safe: true
      });
      return db.open(function(error, client) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        if (settings.user || settings.password) {
          return db.authenticate(settings.user, settings.password, function(error, success) {
            if (success) {
              _this._client = client;
              return callback(null);
            } else {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
          });
        } else {
          _this._client = client;
          return callback(null);
        }
      });
    };

    return MongoDBAdapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new MongoDBAdapter(connection);
  };

}).call(this);
