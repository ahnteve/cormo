// Generated by CoffeeScript 1.9.1
(function() {
  var AdapterBase, CormoTypesObjectId, MongoDBAdapter, ObjectID, _, _buildGroupFields, _buildWhere, _buildWhereSingle, _convertValueToObjectID, _objectIdToString, async, error, mongodb, types,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  try {
    mongodb = require('mongodb');
  } catch (_error) {
    error = _error;
    console.log('Install mongodb module to use this adapter');
    process.exit(1);
  }

  ObjectID = mongodb.ObjectID;

  CormoTypesObjectId = (function() {
    function CormoTypesObjectId() {}

    return CormoTypesObjectId;

  })();

  _ = require('lodash');

  AdapterBase = require('./base');

  async = require('async');

  types = require('../types');

  _convertValueToObjectID = function(value, key) {
    var e;
    try {
      return new ObjectID(value);
    } catch (_error) {
      e = _error;
      throw new Error("'" + key + "' is not a valid id");
    }
  };

  _objectIdToString = function(oid) {
    var str, value;
    oid = oid.id;
    str = '';
    value = oid.charCodeAt(0);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(1);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(2);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(3);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(4);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(5);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(6);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(7);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(8);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(9);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(10);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    value = oid.charCodeAt(11);
    if (value < 16) {
      str += '0';
    }
    str += value.toString(16);
    return str;
  };

  _buildWhereSingle = function(property, key, value, not_op) {
    var is_objectid, keys, property_type_class, sub_key, sub_value;
    if (key !== 'id' && (property == null)) {
      throw new Error("unknown column '" + key + "'");
    }
    property_type_class = property != null ? property.type_class : void 0;
    is_objectid = key === 'id' || property_type_class === CormoTypesObjectId;
    if (Array.isArray(value)) {
      if (is_objectid) {
        value = value.map(function(v) {
          return _convertValueToObjectID(v, key);
        });
      }
      if (not_op) {
        value = {
          $nin: value
        };
      } else {
        value = {
          $in: value
        };
      }
    } else if (typeof value === 'object' && value !== null && (keys = Object.keys(value)).length === 1) {
      sub_key = keys[0];
      switch (sub_key) {
        case '$not':
          return _buildWhereSingle(property, key, value[sub_key], !not_op);
        case '$gt':
        case '$lt':
        case '$gte':
        case '$lte':
          sub_value = value[sub_key];
          if (is_objectid) {
            sub_value = _convertValueToObjectID(sub_value, key);
          } else if (property_type_class === types.Date) {
            sub_value = new Date(sub_value);
          }
          value = _.object([sub_key], [sub_value]);
          if (not_op) {
            value = {
              $not: value
            };
          }
          if (key === 'id') {
            key = '_id';
          }
          return _.object([key], [value]);
        case '$contains':
          if (Array.isArray(value[sub_key])) {
            value = value[sub_key].map(function(v) {
              return new RegExp(v, 'i');
            });
            if (not_op) {
              value = {
                $nin: value
              };
              not_op = false;
            } else {
              value = {
                $in: value
              };
            }
          } else {
            value = new RegExp(value[sub_key], 'i');
          }
          break;
        case '$in':
          if (is_objectid) {
            value[sub_key] = value[sub_key].map(function(v) {
              return _convertValueToObjectID(v, key);
            });
          }
          break;
        default:
          throw new Error("unknown operator '" + sub_key + "'");
      }
      if (not_op) {
        value = {
          $not: value
        };
      }
    } else if (value instanceof RegExp) {
      if (!value.ignoreCase) {
        value = new RegExp(value.source, 'i');
      }
    } else {
      if (is_objectid && (value != null)) {
        value = _convertValueToObjectID(value, key);
      }
      if (not_op) {
        value = {
          $ne: value
        };
      }
    }
    if (key === 'id') {
      key = '_id';
    }
    if (property_type_class === types.Date) {
      value = new Date(value);
    }
    return _.object([key], [value]);
  };

  _buildWhere = function(schema, conditions, conjunction) {
    var after_count, before_count, key, keys, obj, subs;
    if (conjunction == null) {
      conjunction = '$and';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(schema, condition);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return;
      } else if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(schema, conditions[key], '$and');
            case '$or':
              return _buildWhere(schema, conditions[key], '$or');
          }
          return;
        } else {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        }
      } else {
        subs = keys.map(function(key) {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        });
      }
    } else {
      throw new Error("'" + (JSON.stringify(conditions)) + "' is not an object");
    }
    if (subs.length === 0) {

    } else if (subs.length === 1) {
      return subs[0];
    } else {
      if (conjunction === '$and') {
        before_count = _.reduce(subs, (function(memo, sub) {
          return memo + Object.keys(sub).length;
        }), 0);
        subs.unshift({});
        obj = _.extend.apply(_, subs);
        subs.shift();
        keys = Object.keys(obj);
        after_count = keys.length;
        if (before_count === after_count && !_.some(keys, function(key) {
          return key.substr(0, 1) === '$';
        })) {
          return obj;
        }
      }
      return _.object([conjunction], [subs]);
    }
  };

  _buildGroupFields = function(group_by, group_fields) {
    var expr, field, group;
    group = {};
    if (group_by) {
      if (group_by.length === 1) {
        group._id = '$' + group_by[0];
      } else {
        group._id = {};
        group_by.forEach(function(field) {
          return group._id[field] = '$' + field;
        });
      }
    } else {
      group._id = null;
    }
    for (field in group_fields) {
      expr = group_fields[field];
      group[field] = expr;
    }
    return group;
  };

  MongoDBAdapter = (function(superClass) {
    var _getMongoDBColName;

    extend(MongoDBAdapter, superClass);

    MongoDBAdapter.prototype.key_type = types.String;

    MongoDBAdapter.prototype.key_type_internal = CormoTypesObjectId;

    MongoDBAdapter.prototype.support_geopoint = true;

    MongoDBAdapter.prototype.support_nested = true;

    function MongoDBAdapter(connection) {
      this._connection = connection;
      this._collections = {};
    }

    _getMongoDBColName = function(name) {
      if (name === '_archives') {
        return '@archives';
      } else {
        return name;
      }
    };

    MongoDBAdapter.prototype._collection = function(model) {
      var name;
      name = this._connection.models[model].tableName;
      if (!this._collections[name]) {
        return this._collections[name] = this._client.collection(_getMongoDBColName(name));
      } else {
        return this._collections[name];
      }
    };

    MongoDBAdapter.prototype.applySchema = function(model, callback) {
      var collection, column, i, index, indexes, len, property, ref, ref1;
      collection = this._collection(model);
      indexes = [];
      ref = this._connection.models[model]._schema;
      for (column in ref) {
        property = ref[column];
        if (property.unique) {
          if (property.required) {
            indexes.push([
              column, {
                unique: true
              }
            ]);
          } else {
            indexes.push([
              column, {
                unique: true,
                sparse: true
              }
            ]);
          }
        }
        if (property.type_class === types.GeoPoint) {
          indexes.push([_.object([column], ['2d'])]);
        }
      }
      ref1 = this._connection.models[model]._indexes;
      for (i = 0, len = ref1.length; i < len; i++) {
        index = ref1[i];
        if (index.options.unique) {
          indexes.push([
            index.columns, {
              name: index.options.name,
              unique: true,
              sparse: true
            }
          ]);
        } else {
          indexes.push([
            index.columns, {
              name: index.options.name
            }
          ]);
        }
      }
      return async.forEach(indexes, function(index, callback) {
        return collection.ensureIndex(index[0], index[1], function(error) {
          return callback(error);
        });
      }, function(error) {
        return callback(error);
      });
    };

    MongoDBAdapter.prototype.drop = function(model, callback) {
      var name;
      name = this._connection.models[model].tableName;
      delete this._collections[name];
      return this._client.dropCollection(_getMongoDBColName(name), function(error) {
        if (error && error.errmsg !== 'ns not found') {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.idToDB = function(value) {
      return _convertValueToObjectID(value, 'id');
    };

    MongoDBAdapter.prototype.valueToDB = function(value, column, property) {
      if (value == null) {
        return;
      }
      if (column === 'id' || property.type_class === CormoTypesObjectId) {
        if (property.array) {
          return value.map(function(v) {
            return v && _convertValueToObjectID(v, column);
          });
        } else {
          return _convertValueToObjectID(value, column);
        }
      }
      return value;
    };

    MongoDBAdapter.prototype._getModelID = function(data) {
      return _objectIdToString(data._id);
    };

    MongoDBAdapter.prototype.valueToModel = function(value, property) {
      if (property.type_class === CormoTypesObjectId) {
        if (property.array) {
          return value.map(function(v) {
            return v && _objectIdToString(v);
          });
        } else {
          return value && _objectIdToString(value);
        }
      } else {
        return value;
      }
    };

    MongoDBAdapter.prototype.create = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var column, id, key;
        if ((error != null ? error.code : void 0) === 11000) {
          column = '';
          key = error.message.match(/index: [\w-.]+\$(\w+)/);
          if (key != null) {
            column = key[1];
            key = column.match(/(\w+)_1/);
            if (key != null) {
              column = key[1];
            }
            column = ' ' + column;
          }
          return callback(new Error('duplicated' + column));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        id = _objectIdToString(result.ops[0]._id);
        if (id) {
          delete data._id;
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MongoDBAdapter.prototype.createBulk = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var ids, key;
        if ((error != null ? error.code : void 0) === 11000) {
          key = error.message.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        error = void 0;
        ids = result.ops.map(function(doc) {
          var id;
          id = _objectIdToString(doc._id);
          if (id) {
            delete data._id;
          } else {
            error = new Error('unexpected result');
          }
          return id;
        });
        if (error) {
          return callback(error);
        }
        return callback(null, ids);
      });
    };

    MongoDBAdapter.prototype.update = function(model, data, callback) {
      var id;
      id = data.id;
      delete data.id;
      return this._collection(model).update({
        _id: id
      }, data, {
        safe: true
      }, function(error) {
        var key, ref;
        if ((ref = error != null ? error.code : void 0) === 11001 || ref === 11000) {
          key = error.message.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._buildUpdateOps = function(schema, update_ops, data, path, object) {
      var column, property, results, value;
      results = [];
      for (column in object) {
        value = object[column];
        property = schema[path + column];
        if (property) {
          if (value != null) {
            if (value.$inc) {
              results.push(update_ops.$inc[path + column] = value.$inc);
            } else {
              results.push(update_ops.$set[path + column] = value);
            }
          } else {
            results.push(update_ops.$unset[path + column] = '');
          }
        } else if (typeof object[column] === 'object') {
          results.push(this._buildUpdateOps(schema, update_ops, data, path + column + '.', object[column]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    MongoDBAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var e, schema, update_ops;
      schema = this._connection.models[model]._schema;
      try {
        conditions = _buildWhere(schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      if (!conditions) {
        conditions = {};
      }
      update_ops = {
        $set: {},
        $unset: {},
        $inc: {}
      };
      this._buildUpdateOps(schema, update_ops, data, '', data);
      if (Object.keys(update_ops.$set).length === 0) {
        delete update_ops.$set;
      }
      if (Object.keys(update_ops.$unset).length === 0) {
        delete update_ops.$unset;
      }
      if (Object.keys(update_ops.$inc).length === 0) {
        delete update_ops.$inc;
      }
      return this._collection(model).update(conditions, update_ops, {
        safe: true,
        multi: true
      }, function(error, result) {
        var key, ref;
        if ((ref = error != null ? error.code : void 0) === 11001 || ref === 11000) {
          key = error.message.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.result.n);
      });
    };

    MongoDBAdapter.prototype.findById = function(model, id, options, callback) {
      var client_options, e, fields;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        id = _convertValueToObjectID(id, 'id');
      } catch (_error) {
        e = _error;
        return callback(new Error('not found'));
      }
      client_options = {};
      if (fields) {
        client_options.fields = fields;
      }
      if (options.explain) {
        client_options.explain = true;
        return this._collection(model).findOne({
          _id: id
        }, client_options, function(error, result) {
          if (error) {
            return callback(error);
          }
          return callback(null, result);
        });
      }
      return this._collection(model).findOne({
        _id: id
      }, client_options, (function(_this) {
        return function(error, result) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          if (!result) {
            return callback(new Error('not found'));
          }
          if (options.lean) {
            return callback(null, _this._refineRawInstance(model, result, options.select, options.select_raw));
          } else {
            return callback(null, _this._convertToModelInstance(model, result, options.select, options.select_raw));
          }
        };
      })(this));
    };

    MongoDBAdapter.prototype.find = function(model, conditions, options, callback) {
      var client_options, e, field, fields, keys, obj, orders, pipeline;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        if (conditions) {
          keys = Object.keys(conditions);
        }
        if (keys && (keys.length > 1 || keys[0].substr(0, 1) !== '$')) {
          conditions[field] = {
            $near: options.near[field]
          };
        } else {
          obj = {};
          obj[field] = {
            $near: options.near[field]
          };
          if (conditions) {
            conditions = {
              $and: [conditions, obj]
            };
          } else {
            conditions = obj;
          }
        }
      }
      if (options.orders.length > 0) {
        orders = {};
        options.orders.forEach(function(order) {
          var column, dir;
          if (order[0] === '-') {
            column = order.slice(1);
            dir = -1;
          } else {
            column = order;
            dir = 1;
          }
          if (options.group_by) {
            if (options.group_by.length === 1) {
              if (column === options.group_by[0]) {
                column = '_id';
              }
            } else {
              if (options.group_by.indexOf(column) >= 0) {
                column = '_id.' + column;
              }
            }
          } else {
            if (column === 'id') {
              column = '_id';
            }
          }
          return orders[column] = dir;
        });
      }
      if (options.group_by || options.group_fields) {
        pipeline = [];
        if (conditions) {
          pipeline.push({
            $match: conditions
          });
        }
        pipeline.push({
          $group: _buildGroupFields(options.group_by, options.group_fields)
        });
        if (orders) {
          pipeline.push({
            $sort: orders
          });
        }
        if (options.conditions_of_group.length > 0) {
          pipeline.push({
            $match: _buildWhere(options.group_fields, options.conditions_of_group)
          });
        }
        if (options.explain) {
          return this._collection(model).aggregate(pipeline, {
            explain: true
          }, function(error, result) {
            if (error) {
              return callback(error);
            }
            return callback(null, result);
          });
        }
        return this._collection(model).aggregate(pipeline, (function(_this) {
          return function(error, result) {
            if (error) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return callback(null, result.map(function(record) {
              var group, i, len, ref;
              if (options.group_by) {
                if (options.group_by.length === 1) {
                  record[options.group_by[0]] = record._id;
                } else {
                  ref = options.group_by;
                  for (i = 0, len = ref.length; i < len; i++) {
                    group = ref[i];
                    record[group] = record._id[group];
                  }
                }
              }
              return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
            }));
          };
        })(this));
      } else {
        client_options = {
          limit: options.limit,
          skip: options.skip
        };
        if (fields) {
          client_options.fields = fields;
        }
        if (orders) {
          client_options.sort = orders;
        }
        if (options.explain) {
          client_options.explain = true;
          return this._collection(model).find(conditions, client_options, function(error, cursor) {
            if (error) {
              return callback(error);
            }
            return cursor.toArray(function(error, result) {
              if (error) {
                return callback(error);
              }
              return callback(null, result);
            });
          });
        }
        return this._collection(model).find(conditions, client_options, (function(_this) {
          return function(error, cursor) {
            if (error || !cursor) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return cursor.toArray(function(error, result) {
              if (error) {
                return callback(MongoDBAdapter.wrapError('unknown error', error));
              }
              if (options.lean) {
                return callback(null, result.map(function(record) {
                  return _this._refineRawInstance(model, record, options.select, options.select_raw);
                }));
              } else {
                return callback(null, result.map(function(record) {
                  return _this._convertToModelInstance(model, record, options.select, options.select_raw);
                }));
              }
            });
          };
        })(this));
      }
    };

    MongoDBAdapter.prototype.count = function(model, conditions, callback) {
      var e;
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      return this._collection(model).count(conditions, (function(_this) {
        return function(error, count) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          return callback(null, count);
        };
      })(this));
    };

    MongoDBAdapter.prototype["delete"] = function(model, conditions, callback) {
      var e, model_class;
      model_class = this._connection.models[model];
      try {
        conditions = _buildWhere(model_class._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      return this._collection(model).remove(conditions, {
        safe: true
      }, function(error, result) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.result.n);
      });
    };

    MongoDBAdapter.prototype.connect = function(settings, callback) {
      var url;
      if (settings.user || settings.password) {
        url = "mongodb://" + settings.user + ":" + settings.password + "@" + (settings.host || 'localhost') + ":" + (settings.port || 27017) + "/" + settings.database;
      } else {
        url = "mongodb://" + (settings.host || 'localhost') + ":" + (settings.port || 27017) + "/" + settings.database;
      }
      return mongodb.MongoClient.connect(url, (function(_this) {
        return function(error, db) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          _this._client = db;
          return callback(null);
        };
      })(this));
    };

    MongoDBAdapter.prototype.close = function() {
      if (this._client) {
        this._client.close();
      }
      return this._client = null;
    };

    return MongoDBAdapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new MongoDBAdapter(connection);
  };

}).call(this);
