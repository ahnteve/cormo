// Generated by CoffeeScript 1.4.0
(function() {
  var AdapterBase, MongoDBAdapter, ObjectID, async, mongodb, tableize, types, _buildWhere,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    mongodb = require('mongodb');
  } catch (error) {
    console.log('Install mongodb module to use this adapter');
    process.exit(1);
  }

  ObjectID = mongodb.ObjectID;

  AdapterBase = require('./base');

  types = require('../types');

  tableize = require('../inflector').tableize;

  async = require('async');

  _buildWhere = function(schema, conditions, conjunction) {
    var is_objectid, key, keys, obj, sub_key, subs, value;
    if (conjunction == null) {
      conjunction = '$and';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(schema, condition);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return;
      } else if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(schema, conditions[key], '$and');
            case '$or':
              return _buildWhere(schema, conditions[key], '$or');
          }
          return;
        } else {
          is_objectid = key === 'id' || schema[key].type === 'objectid';
          value = conditions[key];
          if (Array.isArray(value)) {
            if (is_objectid) {
              try {
                value = value.map(function(v) {
                  return new ObjectID(v);
                });
              } catch (e) {
                throw new Error("'" + key + "' is not a valid id");
              }
            }
            value = {
              $in: value
            };
          } else if (typeof value === 'object' && (keys = Object.keys(value)).length === 1) {
            sub_key = keys[0];
            switch (sub_key) {
              case '$gt' || '$lt' || '$gte' || '$lte':
                obj = {};
                obj[key] = {};
                obj[key][sub_key] = value[sub_key];
                return obj;
              case '$contains':
                value = new RegExp(value[sub_key], 'i');
                break;
              case '$in':
                if (is_objectid) {
                  try {
                    value[sub_key] = value[sub_key].map(function(v) {
                      return new ObjectID(v);
                    });
                  } catch (e) {
                    throw new Error("'" + key + "' is not a valid id");
                  }
                }
            }
          } else if (is_objectid) {
            try {
              value = new ObjectID(value);
            } catch (e) {
              throw new Error("'" + key + "' is not a valid id");
            }
          }
          if (key === 'id') {
            key = '_id';
          }
          obj = {};
          obj[key] = value;
          return obj;
        }
      } else {
        subs = keys.map(function(key) {
          obj = {};
          obj[key] = conditions[key];
          return _buildWhere(schema, obj);
        });
      }
    } else {
      return;
    }
    if (subs.length === 0) {
      return;
    }
    if (subs.length === 1) {
      return subs[0];
    }
    obj = {};
    obj[conjunction] = subs;
    return obj;
  };

  /*
  # Adapter for MongoDB
  */


  MongoDBAdapter = (function(_super) {

    __extends(MongoDBAdapter, _super);

    MongoDBAdapter.prototype.key_type = types.String;

    MongoDBAdapter.prototype.key_type_internal = 'objectid';

    MongoDBAdapter.prototype.support_geopoint = true;

    /*
      # Creates a MongoDB adapter
    */


    function MongoDBAdapter(connection) {
      this._connection = connection;
      this._collections = {};
    }

    MongoDBAdapter.prototype._collection = function(name) {
      name = tableize(name);
      if (!this._collections[name]) {
        return this._collections[name] = new mongodb.Collection(this._client, name);
      } else {
        return this._collections[name];
      }
    };

    MongoDBAdapter.prototype._applySchema = function(model, callback) {
      var collection, column, indexes, obj, property, _ref;
      collection = this._collection(model);
      indexes = [];
      _ref = this._connection.models[model]._schema;
      for (column in _ref) {
        property = _ref[column];
        if (property.unique) {
          indexes.push([
            column, {
              safe: true,
              unique: true,
              sparse: true
            }
          ]);
        }
        if (property.type === types.GeoPoint) {
          obj = {};
          obj[column] = '2d';
          indexes.push([obj]);
        }
      }
      return async.forEach(indexes, function(index, callback) {
        return collection.ensureIndex(index[0], index[1], function(error) {
          return callback(error);
        });
      }, function(error) {
        return callback(error);
      });
    };

    /*
      # Ensures indexes
      # @param {Function} callback
      # @param {Error} callback.error
      # @see Connection.applySchemas
    */


    MongoDBAdapter.prototype.applySchemas = function(callback) {
      var _this = this;
      return async.forEach(Object.keys(this._connection.models), function(model, callback) {
        return _this._applySchema(model, callback);
      }, function(error) {
        return callback(error);
      });
    };

    /*
      # Drops a model from the database
      # @param {String} model
      # @param {Function} callback
      # @param {Error} callback.error
      # @see Model.drop
    */


    MongoDBAdapter.prototype.drop = function(model, callback) {
      var name;
      name = tableize(model);
      delete this._collections[name];
      return this._client.dropCollection(name, function(error) {
        if (error && error.errmsg !== 'ns not found') {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._buildSaveData = function(model, data, callback) {
      var schema;
      schema = this._connection.models[model]._schema;
      Object.keys(data).forEach(function(field) {
        if (!(data[field] != null)) {
          return delete data[field];
        } else if (schema[field].type === 'objectid') {
          try {
            return data[field] = new ObjectID(data[field]);
          } catch (e) {
            callback(new Error("'" + field + "' is not a ID"));
            return false;
          }
        }
      });
      return true;
    };

    /*
      # Creates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {RecordID} callback.id
    */


    MongoDBAdapter.prototype.create = function(model, data, callback) {
      if (!this._buildSaveData(model, data, callback)) {
        return;
      }
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var id, key, _ref;
        if ((error != null ? error.code : void 0) === 11000) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        id = result != null ? (_ref = result[0]) != null ? _ref._id.toString() : void 0 : void 0;
        if (id) {
          delete data._id;
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    /*
      # Updates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
    */


    MongoDBAdapter.prototype.update = function(model, data, callback) {
      var id;
      try {
        id = new ObjectID(data.id);
        delete data.id;
      } catch (e) {
        return callback(new Error('unknown error'));
      }
      if (!this._buildSaveData(model, data, callback)) {
        return;
      }
      return this._collection(model).update({
        _id: id
      }, data, {
        safe: true
      }, function(error) {
        var key;
        if ((error != null ? error.code : void 0) === 11001) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._convertToModelInstance = function(model, data) {
      var column, modelClass, property, record, _ref;
      modelClass = this._connection.models[model];
      record = new modelClass();
      Object.defineProperty(record, 'id', {
        configurable: false,
        enumerable: true,
        writable: false,
        value: data._id.toString()
      });
      _ref = modelClass._schema;
      for (column in _ref) {
        property = _ref[column];
        if (!(data[column] != null)) {
          continue;
        }
        if (property.type === 'objectid') {
          record[column] = data[column].toString();
        } else {
          record[column] = data[column];
        }
      }
      return record;
    };

    /*
      # Finds a record by id
      # @param {String} model
      # @param {RecordID} id
      # @param {Object} options
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Model} callback.record
      # @throws Error('not found')
    */


    MongoDBAdapter.prototype.findById = function(model, id, options, callback) {
      var fields,
        _this = this;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        id = new ObjectID(id);
      } catch (e) {
        return callback(new Error('not found'));
      }
      options = {};
      if (fields) {
        options.fields = fields;
      }
      return this._collection(model).findOne({
        _id: id
      }, options, function(error, result) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        if (!result) {
          return callback(new Error('not found'));
        }
        return callback(null, _this._convertToModelInstance(model, result));
      });
    };

    /*
      # Finds records
      # @param {String} model
      # @param {Object} conditions
      # @param {Object} options
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Array<Model>} callback.records
    */


    MongoDBAdapter.prototype.find = function(model, conditions, options, callback) {
      var field, fields, obj,
        _this = this;
      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        obj = {};
        obj[field] = {
          $near: options.near[field]
        };
        if (conditions) {
          conditions = {
            $and: [conditions, obj]
          };
        } else {
          conditions = obj;
        }
      }
      options = {
        limit: options.limit
      };
      if (fields) {
        options.fields = fields;
      }
      return this._collection(model).find(conditions, options, function(error, cursor) {
        if (error || !cursor) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return cursor.toArray(function(error, result) {
          if (error || !cursor) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          return callback(null, result.map(function(record) {
            return _this._convertToModelInstance(model, record);
          }));
        });
      });
    };

    /*
      # Counts records
      # @param {String} model
      # @param {Object} conditions
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Number} callback.count
    */


    MongoDBAdapter.prototype.count = function(model, conditions, callback) {
      var _this = this;
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      return this._collection(model).count(conditions, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    /*
      # Deletes records from the database
      # @param {String} model
      # @param {Object} conditions
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Number} callback.count
    */


    MongoDBAdapter.prototype["delete"] = function(model, conditions, callback) {
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (e) {
        return callback(e);
      }
      return this._collection(model).remove(conditions, {
        safe: true
      }, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    /*
      # Connects to the database
      # @param {Object} settings
      # @param {String} [settings.host='localhost']
      # @param {Number} [settings.port=27017]
      # @param {String} settings.database
      # @param {Function} callback
      # @param {Error} callback.error
    */


    MongoDBAdapter.prototype.connect = function(settings, callback) {
      var db, server,
        _this = this;
      server = new mongodb.Server(settings.host || 'localhost', settings.port || 27017, {});
      db = new mongodb.Db(settings.database, server, {});
      return db.open(function(error, client) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        _this._client = client;
        return callback(null);
      });
    };

    return MongoDBAdapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new MongoDBAdapter(connection);
  };

}).call(this);
