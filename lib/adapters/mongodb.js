// Generated by CoffeeScript 1.6.2
(function() {
  var AdapterBase, MongoDBAdapter, ObjectID, async, error, mongodb, tableize, types, _, _buildGroupFields, _buildWhere, _buildWhereSingle, _convertValueToObjectID,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    mongodb = require('mongodb');
  } catch (_error) {
    error = _error;
    console.log('Install mongodb module to use this adapter');
    process.exit(1);
  }

  ObjectID = mongodb.ObjectID;

  AdapterBase = require('./base');

  types = require('../types');

  tableize = require('../inflector').tableize;

  async = require('async');

  _ = require('underscore');

  _convertValueToObjectID = function(value, key) {
    var e;

    try {
      return new ObjectID(value);
    } catch (_error) {
      e = _error;
      throw new Error("'" + key + "' is not a valid id");
    }
  };

  _buildWhereSingle = function(property, key, value, not_op) {
    var is_objectid, keys, obj, property_type, sub_key, sub_value;

    if (key !== 'id' && (property == null)) {
      throw new Error("unknown column '" + key + "'");
    }
    property_type = property != null ? property.type : void 0;
    is_objectid = key === 'id' || property_type === 'objectid';
    if (Array.isArray(value)) {
      if (is_objectid) {
        value = value.map(function(v) {
          return _convertValueToObjectID(v, key);
        });
      }
      if (not_op) {
        value = {
          $nin: value
        };
      } else {
        value = {
          $in: value
        };
      }
    } else if (typeof value === 'object' && value !== null && (keys = Object.keys(value)).length === 1) {
      sub_key = keys[0];
      switch (sub_key) {
        case '$not':
          return _buildWhereSingle(property, key, value[sub_key], !not_op);
        case '$gt':
        case '$lt':
        case '$gte':
        case '$lte':
          sub_value = value[sub_key];
          if (property_type === types.Date) {
            sub_value = new Date(sub_value);
          }
          value = {};
          value[sub_key] = sub_value;
          if (not_op) {
            value = {
              $not: value
            };
          }
          obj = {};
          obj[key] = value;
          return obj;
        case '$contains':
          value = new RegExp(value[sub_key], 'i');
          break;
        case '$in':
          if (is_objectid) {
            value[sub_key] = value[sub_key].map(function(v) {
              return _convertValueToObjectID(v, key);
            });
          }
          break;
        default:
          throw new Error("unknown operator '" + sub_key + "'");
      }
      if (not_op) {
        value = {
          $not: value
        };
      }
    } else {
      if (is_objectid && (value != null)) {
        value = _convertValueToObjectID(value, key);
      }
      if (not_op) {
        value = {
          $ne: value
        };
      }
    }
    obj = {};
    if (key === 'id') {
      key = '_id';
    }
    if (property_type === types.Date) {
      value = new Date(value);
    }
    obj[key] = value;
    return obj;
  };

  _buildWhere = function(schema, conditions, conjunction) {
    var key, keys, obj, subs;

    if (conjunction == null) {
      conjunction = '$and';
    }
    if (Array.isArray(conditions)) {
      subs = conditions.map(function(condition) {
        return _buildWhere(schema, condition);
      });
    } else if (typeof conditions === 'object') {
      keys = Object.keys(conditions);
      if (keys.length === 0) {
        return;
      } else if (keys.length === 1) {
        key = keys[0];
        if (key.substr(0, 1) === '$') {
          switch (key) {
            case '$and':
              return _buildWhere(schema, conditions[key], '$and');
            case '$or':
              return _buildWhere(schema, conditions[key], '$or');
          }
          return;
        } else {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        }
      } else {
        subs = keys.map(function(key) {
          return _buildWhereSingle(schema[key], key, conditions[key]);
        });
      }
    } else {
      throw new Error("'" + (JSON.stringify(conditions)) + "' is not an object");
    }
    if (subs.length === 0) {

    } else if (subs.length === 1) {
      return subs[0];
    } else {
      if (conjunction === '$and') {
        subs.unshift({});
        obj = _.extend.apply(_, subs);
        subs.shift();
        keys = Object.keys(obj);
        if (!_.some(keys, function(key) {
          return key.substr(0, 1) === '$';
        })) {
          return obj;
        }
      }
      obj = {};
      obj[conjunction] = subs;
      return obj;
    }
  };

  _buildGroupFields = function(group_by, group_fields) {
    var expr, field, group;

    group = {};
    if (group_by) {
      if (group_by.length === 1) {
        group._id = '$' + group_by[0];
      } else {
        group._id = {};
        group_by.forEach(function(field) {
          return group._id[field] = '$' + field;
        });
      }
    } else {
      group._id = null;
    }
    for (field in group_fields) {
      expr = group_fields[field];
      group[field] = expr;
    }
    return group;
  };

  MongoDBAdapter = (function(_super) {
    var _getMongoDBColName;

    __extends(MongoDBAdapter, _super);

    MongoDBAdapter.prototype.key_type = types.String;

    MongoDBAdapter.prototype.key_type_internal = 'objectid';

    MongoDBAdapter.prototype.support_geopoint = true;

    MongoDBAdapter.prototype.support_nested = true;

    function MongoDBAdapter(connection) {
      this._connection = connection;
      this._collections = {};
    }

    _getMongoDBColName = function(name) {
      if (name === '_archives') {
        return '@archives';
      } else {
        return name;
      }
    };

    MongoDBAdapter.prototype._collection = function(name) {
      name = tableize(name);
      if (!this._collections[name]) {
        return this._collections[name] = new mongodb.Collection(this._client, _getMongoDBColName(name));
      } else {
        return this._collections[name];
      }
    };

    MongoDBAdapter.prototype.applySchema = function(model, callback) {
      var collection, column, index, indexes, obj, property, _i, _len, _ref, _ref1;

      collection = this._collection(model);
      indexes = [];
      _ref = this._connection.models[model]._schema;
      for (column in _ref) {
        property = _ref[column];
        if (property.unique) {
          if (property.required) {
            indexes.push([
              column, {
                unique: true
              }
            ]);
          } else {
            indexes.push([
              column, {
                unique: true,
                sparse: true
              }
            ]);
          }
        }
        if (property.type === types.GeoPoint) {
          obj = {};
          obj[column] = '2d';
          indexes.push([obj]);
        }
      }
      _ref1 = this._connection.models[model]._indexes;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        index = _ref1[_i];
        if (index.options.unique) {
          indexes.push([
            index.columns, {
              name: index.options.name,
              unique: true,
              sparse: true
            }
          ]);
        } else {
          indexes.push([
            index.columns, {
              name: index.options.name
            }
          ]);
        }
      }
      return async.forEach(indexes, function(index, callback) {
        return collection.ensureIndex(index[0], index[1], function(error) {
          return callback(error);
        });
      }, function(error) {
        return callback(error);
      });
    };

    MongoDBAdapter.prototype.drop = function(model, callback) {
      var name;

      name = tableize(model);
      delete this._collections[name];
      return this._client.dropCollection(_getMongoDBColName(name), function(error) {
        if (error && error.errmsg !== 'ns not found') {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype.idToDB = function(value) {
      var e;

      try {
        return new ObjectID(value);
      } catch (_error) {
        e = _error;
        throw new Error("'id' is not a valid ID");
      }
    };

    MongoDBAdapter.prototype.valueToDB = function(value, column, property) {
      var e;

      if (value == null) {
        return;
      }
      if (column === 'id' || property.type === 'objectid') {
        try {
          return new ObjectID(value);
        } catch (_error) {
          e = _error;
          throw new Error("'" + column + "' is not a valid ID");
        }
      }
      return value;
    };

    MongoDBAdapter.prototype._getModelID = function(data) {
      return data._id.toString();
    };

    MongoDBAdapter.prototype.valueToModel = function(value, column, property) {
      if (property.type === 'objectid') {
        return value.toString();
      } else {
        return value;
      }
    };

    MongoDBAdapter.prototype.create = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var column, id, key, _ref;

        if ((error != null ? error.code : void 0) === 11000) {
          column = '';
          key = error.err.match(/index: [\w-.]+\$(\w+)/);
          if (key != null) {
            column = key[1];
            key = column.match(/(\w+)_1/);
            if (key != null) {
              column = key[1];
            }
            column = ' ' + column;
          }
          return callback(new Error('duplicated' + column));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        id = result != null ? (_ref = result[0]) != null ? _ref._id.toString() : void 0 : void 0;
        if (id) {
          delete data._id;
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MongoDBAdapter.prototype.createBulk = function(model, data, callback) {
      return this._collection(model).insert(data, {
        safe: true
      }, function(error, result) {
        var ids, key;

        if ((error != null ? error.code : void 0) === 11000) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        error = void 0;
        ids = result.map(function(doc) {
          var id;

          id = doc._id.toString();
          if (id) {
            delete data._id;
          } else {
            error = new Error('unexpected result');
          }
          return id;
        });
        if (error) {
          return callback(error);
        }
        return callback(null, ids);
      });
    };

    MongoDBAdapter.prototype.update = function(model, data, callback) {
      var id;

      id = data.id;
      delete data.id;
      return this._collection(model).update({
        _id: id
      }, data, {
        safe: true
      }, function(error) {
        var key;

        if ((error != null ? error.code : void 0) === 11001) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MongoDBAdapter.prototype._buildUpdateOps = function(schema, update_ops, data, path, object) {
      var column, property, value, _results;

      _results = [];
      for (column in object) {
        value = object[column];
        property = schema[path + column];
        if (property) {
          if (value != null) {
            _results.push(update_ops.$set[path + column] = value);
          } else {
            _results.push(update_ops.$unset[path + column] = '');
          }
        } else if (typeof object[column] === 'object') {
          _results.push(this._buildUpdateOps(schema, update_ops, data, path + column + '.', object[column]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    MongoDBAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var e, schema, update_ops;

      schema = this._connection.models[model]._schema;
      try {
        conditions = _buildWhere(schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      if (!conditions) {
        conditions = {};
      }
      update_ops = {
        $set: {},
        $unset: {}
      };
      this._buildUpdateOps(schema, update_ops, data, '', data);
      return this._collection(model).update(conditions, update_ops, {
        safe: true,
        multi: true
      }, function(error, count) {
        var key;

        if ((error != null ? error.code : void 0) === 11001) {
          key = error.err.match(/index: [\w-.]+\$(\w+)_1/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype.findById = function(model, id, options, callback) {
      var client_options, e, fields,
        _this = this;

      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        id = new ObjectID(id);
      } catch (_error) {
        e = _error;
        return callback(new Error('not found'));
      }
      client_options = {};
      if (fields) {
        client_options.fields = fields;
      }
      return this._collection(model).findOne({
        _id: id
      }, client_options, function(error, result) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        if (!result) {
          return callback(new Error('not found'));
        }
        return callback(null, _this._convertToModelInstance(model, result, options.select));
      });
    };

    MongoDBAdapter.prototype.find = function(model, conditions, options, callback) {
      var client_options, e, field, fields, keys, obj, orders, pipeline,
        _this = this;

      if (options.select) {
        fields = {};
        options.select.forEach(function(column) {
          return fields[column] = 1;
        });
      }
      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        if (conditions) {
          keys = Object.keys(conditions);
        }
        if (keys && (keys.length > 1 || keys[0].substr(0, 1) !== '$')) {
          conditions[field] = {
            $near: options.near[field]
          };
        } else {
          obj = {};
          obj[field] = {
            $near: options.near[field]
          };
          if (conditions) {
            conditions = {
              $and: [conditions, obj]
            };
          } else {
            conditions = obj;
          }
        }
      }
      if (options.orders.length > 0) {
        orders = {};
        options.orders.forEach(function(order) {
          if (order[0] === '-') {
            return orders[order.slice(1)] = -1;
          } else {
            return orders[order] = 1;
          }
        });
      }
      client_options = {
        limit: options.limit
      };
      if (fields) {
        client_options.fields = fields;
      }
      if (orders) {
        client_options.sort = orders;
      }
      if (options.group_by || options.group_fields) {
        pipeline = [];
        if (conditions) {
          pipeline.push({
            $match: conditions
          });
        }
        pipeline.push({
          $group: _buildGroupFields(options.group_by, options.group_fields)
        });
        return this._collection(model).aggregate(pipeline, function(error, result) {
          if (error) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          return callback(null, result.map(function(record) {
            if (options.group_by) {
              if (options.group_by.length === 1) {
                record[options.group_by[0]] = record._id;
              }
            }
            return _this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
          }));
        });
      } else {
        return this._collection(model).find(conditions, client_options, function(error, cursor) {
          if (error || !cursor) {
            return callback(MongoDBAdapter.wrapError('unknown error', error));
          }
          return cursor.toArray(function(error, result) {
            if (error) {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
            return callback(null, result.map(function(record) {
              return _this._convertToModelInstance(model, record, options.select);
            }));
          });
        });
      }
    };

    MongoDBAdapter.prototype.count = function(model, conditions, callback) {
      var e,
        _this = this;

      try {
        conditions = _buildWhere(this._connection.models[model]._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      return this._collection(model).count(conditions, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype["delete"] = function(model, conditions, callback) {
      var e, model_class;

      model_class = this._connection.models[model];
      try {
        conditions = _buildWhere(model_class._schema, conditions);
      } catch (_error) {
        e = _error;
        return callback(e);
      }
      return this._collection(model).remove(conditions, {
        safe: true
      }, function(error, count) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        return callback(null, count);
      });
    };

    MongoDBAdapter.prototype.connect = function(settings, callback) {
      var db, server,
        _this = this;

      server = new mongodb.Server(settings.host || 'localhost', settings.port || 27017, {});
      db = new mongodb.Db(settings.database, server, {
        safe: true
      });
      return db.open(function(error, client) {
        if (error) {
          return callback(MongoDBAdapter.wrapError('unknown error', error));
        }
        if (settings.user || settings.password) {
          return db.authenticate(settings.user, settings.password, function(error, success) {
            if (success) {
              _this._client = client;
              return callback(null);
            } else {
              return callback(MongoDBAdapter.wrapError('unknown error', error));
            }
          });
        } else {
          _this._client = client;
          return callback(null);
        }
      });
    };

    return MongoDBAdapter;

  })(AdapterBase);

  module.exports = function(connection) {
    return new MongoDBAdapter(connection);
  };

}).call(this);
