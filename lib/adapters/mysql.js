// Generated by CoffeeScript 1.4.0
(function() {
  var MySQLAdapter, SQLAdapterBase, async, mysql, tableize, types, _, _propertyToSQL, _typeToSQL,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    mysql = require('mysql');
  } catch (e) {
    console.log('Install mysql module to use this adapter');
    process.exit(1);
  }

  SQLAdapterBase = require('./sql_base');

  types = require('../types');

  tableize = require('../inflector').tableize;

  async = require('async');

  _ = require('underscore');

  _typeToSQL = function(property) {
    switch (property.type) {
      case types.String:
        return 'VARCHAR(255)';
      case types.Number:
        return 'DOUBLE';
      case types.Boolean:
        return 'BOOLEAN';
      case types.Integer:
        return 'INT';
      case types.GeoPoint:
        return 'POINT';
      case types.Date:
        return 'DATETIME';
      case types.Object:
        return 'VARCHAR(255)';
    }
  };

  _propertyToSQL = function(property) {
    var type;
    type = _typeToSQL(property);
    if (type) {
      if (property.required) {
        type += ' NOT NULL';
      } else {
        type += ' NULL';
      }
      if (property.unique) {
        type += ' UNIQUE';
      }
      return type;
    }
  };

  MySQLAdapter = (function(_super) {
    var _processSaveError;

    __extends(MySQLAdapter, _super);

    MySQLAdapter.prototype.key_type = types.Integer;

    MySQLAdapter.prototype.support_geopoint = true;

    function MySQLAdapter(connection) {
      this._connection = connection;
    }

    MySQLAdapter.prototype._query = function(sql, data, callback) {
      return this._client.query(sql, data, callback);
    };

    MySQLAdapter.prototype._createTable = function(model, callback) {
      var column, column_sql, property, sql, table, _ref;
      table = tableize(model);
      sql = [];
      sql.push('id INT NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY');
      _ref = this._connection.models[model]._schema;
      for (column in _ref) {
        property = _ref[column];
        column_sql = _propertyToSQL(property);
        if (column_sql) {
          sql.push(property._dbname + ' ' + column_sql);
        }
      }
      sql = "CREATE TABLE " + table + " ( " + (sql.join(',')) + " )";
      return this._query(sql, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype._alterTable = function(model, columns, callback) {
      return callback(null);
    };

    MySQLAdapter.prototype._applySchema = function(model, callback) {
      var _this = this;
      return this._query("SHOW COLUMNS FROM " + (tableize(model)), function(error, columns) {
        if ((error != null ? error.code : void 0) === 'ER_NO_SUCH_TABLE') {
          return _this._createTable(model, callback);
        } else {
          return _this._alterTable(model, columns, callback);
        }
      });
    };

    MySQLAdapter.prototype.applySchemas = function(callback) {
      var _this = this;
      return async.forEach(Object.keys(this._connection.models), function(model, callback) {
        return _this._applySchema(model, callback);
      }, function(error) {
        return callback(error);
      });
    };

    MySQLAdapter.prototype.drop = function(model, callback) {
      var table;
      table = tableize(model);
      return this._query("DROP TABLE IF EXISTS " + table, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype._getModelID = function(data) {
      return Number(data.id);
    };

    MySQLAdapter.prototype.valueToModel = function(value, column, property) {
      if (property.type === types.Object) {
        return JSON.parse(value);
      } else if (property.type === types.GeoPoint) {
        return [value.x, value.y];
      } else if (property.type === types.Boolean) {
        return value !== 0;
      } else {
        return value;
      }
    };

    _processSaveError = function(error, callback) {
      var key;
      if (error.code === 'ER_NO_SUCH_TABLE') {
        error = new Error('table does not exist');
      } else if (error.code === 'ER_DUP_ENTRY') {
        key = error.message.match(/for key '([^']*)'/);
        error = new Error('duplicated ' + (key != null ? key[1] : void 0));
      } else if (error.code === 'ER_BAD_NULL_ERROR') {
        key = error.message.match(/Column '([^']*)'/);
        error = new Error("'" + (key != null ? key[1] : void 0) + "' is required");
      } else {
        error = MySQLAdapter.wrapError('unknown error', error);
      }
      return callback(error);
    };

    MySQLAdapter.prototype._buildUpdateSetOfColumn = function(property, data, values, fields, places, insert) {
      var dbname;
      dbname = property._dbname;
      if (property.type === types.GeoPoint) {
        values.push(data[dbname][0]);
        values.push(data[dbname][1]);
        if (insert) {
          fields.push(dbname);
          return places.push('POINT(?,?)');
        } else {
          return fields.push(dbname + '=POINT(?,?)');
        }
      } else {
        values.push(data[dbname]);
        if (insert) {
          fields.push(dbname);
          return places.push('?');
        } else {
          return fields.push(dbname + '=?');
        }
      }
    };

    MySQLAdapter.prototype._buildUpdateSet = function(model, data, values, insert) {
      var column, fields, places, property, schema;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in schema) {
        property = schema[column];
        this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
      }
      return [fields.join(','), places.join(',')];
    };

    MySQLAdapter.prototype._buildPartialUpdateSet = function(model, data, values) {
      var column, fields, places, property, schema, value;
      schema = this._connection.models[model]._schema;
      fields = [];
      places = [];
      for (column in data) {
        value = data[column];
        property = _.find(schema, function(item) {
          return item._dbname === column;
        });
        this._buildUpdateSetOfColumn(property, data, values, fields, places);
      }
      return [fields.join(','), places.join(',')];
    };

    MySQLAdapter.prototype.create = function(model, data, callback) {
      var fields, places, sql, values, _ref;
      values = [];
      _ref = this._buildUpdateSet(model, data, values, true), fields = _ref[0], places = _ref[1];
      sql = "INSERT INTO " + (tableize(model)) + " (" + fields + ") VALUES (" + places + ")";
      return this._query(sql, values, function(error, result) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        if (id = result != null ? result.insertId : void 0) {
          return callback(null, id);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MySQLAdapter.prototype.createBulk = function(model, data, callback) {
      var fields, places, sql, values,
        _this = this;
      values = [];
      fields = void 0;
      places = [];
      data.forEach(function(item) {
        var places_sub, _ref;
        _ref = _this._buildUpdateSet(model, item, values, true), fields = _ref[0], places_sub = _ref[1];
        return places.push('(' + places_sub + ')');
      });
      sql = "INSERT INTO " + (tableize(model)) + " (" + fields + ") VALUES " + (places.join(','));
      return this._query(sql, values, function(error, result) {
        var id;
        if (error) {
          return _processSaveError(error, callback);
        }
        if (id = result != null ? result.insertId : void 0) {
          return callback(null, data.map(function(item, i) {
            return id + i;
          }));
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    MySQLAdapter.prototype.update = function(model, data, callback) {
      var fields, sql, values;
      values = [];
      fields = this._buildUpdateSet(model, data, values)[0];
      values.push(data.id);
      sql = "UPDATE " + (tableize(model)) + " SET " + fields + " WHERE id=?";
      return this._query(sql, values, function(error) {
        if (error) {
          return _processSaveError(error, callback);
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype.updatePartial = function(model, data, conditions, options, callback) {
      var fields, sql, values;
      values = [];
      fields = this._buildPartialUpdateSet(model, data, values)[0];
      sql = "UPDATE " + (tableize(model)) + " SET " + fields;
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(conditions, values);
      }
      return this._query(sql, values, function(error, result) {
        if (error) {
          return _processSaveError(error, callback);
        }
        if (!(result != null)) {
          return callback(MySQLAdapter.wrapError('unknown error'));
        }
        return callback(null, result.affectedRows);
      });
    };

    MySQLAdapter.prototype.findById = function(model, id, options, callback) {
      var selects, sql,
        _this = this;
      if (options.select) {
        selects = 'id,' + options.select.join(',');
      } else {
        selects = '*';
      }
      sql = "SELECT " + selects + " FROM " + (tableize(model)) + " WHERE id=? LIMIT 1";
      return this._query(sql, id, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        if ((result != null ? result.length : void 0) === 1) {
          return callback(null, _this._convertToModelInstance(model, result[0]));
        } else if ((result != null ? result.length : void 0) > 1) {
          return callback(new Error('unknown error'));
        } else {
          return callback(new Error('not found'));
        }
      });
    };

    MySQLAdapter.prototype.find = function(model, conditions, options, callback) {
      var field, location, order_by, orders, params, selects, sql,
        _this = this;
      if (options.select) {
        selects = 'id,' + options.select.join(',');
      } else {
        selects = '*';
      }
      if ((options.near != null) && (field = Object.keys(options.near)[0])) {
        order_by = "" + field + "_distance";
        location = options.near[field];
        selects += ",GLENGTH(LINESTRING(" + field + ",POINT(" + location[0] + "," + location[1] + "))) AS " + field + "_distance";
      }
      params = [];
      sql = "SELECT " + selects + " FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(conditions, params);
      }
      if ((options != null ? options.orders.length : void 0) > 0 || order_by) {
        orders = options.orders.map(function(order) {
          if (order[0] === '-') {
            return order.slice(1) + ' DESC';
          } else {
            return order + ' ASC';
          }
        });
        if (order_by) {
          orders.push(order_by);
        }
        sql += ' ORDER BY ' + orders.join(',');
      }
      if ((options != null ? options.limit : void 0) != null) {
        sql += ' LIMIT ' + options.limit;
      }
      return this._query(sql, params, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.map(function(record) {
          return _this._convertToModelInstance(model, record);
        }));
      });
    };

    MySQLAdapter.prototype.count = function(model, conditions, callback) {
      var params, sql,
        _this = this;
      params = [];
      sql = "SELECT COUNT(*) AS count FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(conditions, params);
      }
      return this._query(sql, params, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        if ((result != null ? result.length : void 0) !== 1) {
          return callback(error('unknown error'));
        }
        return callback(null, Number(result[0].count));
      });
    };

    MySQLAdapter.prototype["delete"] = function(model, conditions, callback) {
      var params, sql;
      params = [];
      sql = "DELETE FROM " + (tableize(model));
      if (conditions.length > 0) {
        sql += ' WHERE ' + this._buildWhere(conditions, params);
      }
      return this._query(sql, params, function(error, result) {
        if (error || !(result != null)) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.affectedRows);
      });
    };

    MySQLAdapter.prototype.connect = function(settings, callback) {
      var client,
        _this = this;
      client = mysql.createConnection({
        host: settings.host,
        port: settings.port,
        user: settings.user,
        password: settings.password
      });
      return client.connect(function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('failed to connect', error));
        }
        _this._client = client;
        return client.query("USE `" + settings.database + "`", function(error) {
          var msg;
          if (!error) {
            return callback(null);
          }
          if (error.code === 'ER_BAD_DB_ERROR') {
            return client.query("CREATE DATABASE `" + settings.database + "`", function(error) {
              if (error) {
                return callback(MySQLAdapter.wrapError('unknown error', error));
              }
              return callback(null);
            });
          } else {
            msg = error.code === 'ER_DBACCESS_DENIED_ERROR' ? "no access right to the database '" + settings.database + "'" : 'unknown error';
            return callback(MySQLAdapter.wrapError(msg, error));
          }
        });
      });
    };

    return MySQLAdapter;

  })(SQLAdapterBase);

  module.exports = function(connection) {
    return new MySQLAdapter(connection);
  };

}).call(this);
