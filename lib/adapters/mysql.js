// Generated by CoffeeScript 1.3.3
(function() {
  var AdapterBase, DBModel, MySQLAdapter, async, mysql, tableize, _propertyToSQL, _typeToSQL,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  try {
    mysql = require('mysql');
  } catch (e) {
    console.log('Install mysql module to use this adapter');
    process.exit(1);
  }

  AdapterBase = require('./base');

  DBModel = require('../model');

  tableize = require('../inflector').tableize;

  async = require('async');

  _typeToSQL = function(property) {
    switch (property.type) {
      case DBModel.String:
        return 'VARCHAR(255)';
      case DBModel.Number:
        return 'INT(11)';
      case DBModel.ForeignKey:
        return 'BIGINT';
    }
  };

  _propertyToSQL = function(property) {
    var type;
    type = _typeToSQL(property);
    if (type) {
      type += ' NULL';
      if (property.unique) {
        type += ' UNIQUE';
      }
      return type;
    }
  };

  /*
  # Adapter for MySQL
  */


  MySQLAdapter = (function(_super) {

    __extends(MySQLAdapter, _super);

    /*
      # Creates a MySQL adapter
      # @param {mysql.Connection} client
    */


    function MySQLAdapter(connection, client) {
      this._connection = connection;
      this._client = client;
    }

    MySQLAdapter.prototype._query = function(sql, data, callback) {
      return this._client.query(sql, data, callback);
    };

    MySQLAdapter.prototype._createTable = function(model, callback) {
      var field, field_sql, property, sql, table, _ref;
      table = tableize(model);
      sql = [];
      sql.push('id BIGINT NOT NULL AUTO_INCREMENT UNIQUE PRIMARY KEY');
      _ref = this._connection.models[model]._schema;
      for (field in _ref) {
        property = _ref[field];
        field_sql = _propertyToSQL(property);
        if (field_sql) {
          sql.push(field + ' ' + field_sql);
        }
      }
      sql = "CREATE TABLE " + table + " ( " + (sql.join(',')) + " )";
      return this._query(sql, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype._alterTable = function(model, fields, callback) {
      return callback(null);
    };

    MySQLAdapter.prototype._applySchema = function(model, callback) {
      var table,
        _this = this;
      table = tableize(model);
      return this._query("SHOW FIELDS FROM " + table, function(error, fields) {
        if ((error != null ? error.code : void 0) === 'ER_NO_SUCH_TABLE') {
          return _this._createTable(model, callback);
        } else {
          return _this._alterTable(model, fields, callback);
        }
      });
    };

    /*
      # Creates or alters tables reflecting schemas
      # @param {Function} callback
      # @param {Error} callback.error
      # @see DBConnection.applySchemas
    */


    MySQLAdapter.prototype.applySchemas = function(callback) {
      var _this = this;
      return async.forEach(Object.keys(this._connection.models), function(model, callback) {
        return _this._applySchema(model, callback);
      }, function(error) {
        return callback(error);
      });
    };

    /*
      # Drops a model from the database
      # @param {String} model
      # @param {Function} callback
      # @param {Error} callback.error
      # @see DBModel.drop
    */


    MySQLAdapter.prototype.drop = function(model, callback) {
      var table;
      table = tableize(model);
      return this._query("DROP TABLE IF EXISTS " + table, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    /*
      # Deletes all records from the database
      # @param {String} model
      # @param {Function} callback
      # @param {Error} callback.error
      # @see DBModel.deleteAll
    */


    MySQLAdapter.prototype.deleteAll = function(model, callback) {
      var table;
      table = tableize(model);
      return this._query("DELETE FROM " + table, function(error) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    /*
      # Creates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {String} callback.id
    */


    MySQLAdapter.prototype.create = function(model, data, callback) {
      var table;
      table = tableize(model);
      return this._query("INSERT INTO " + table + " SET ?", data, function(error, result) {
        var key;
        if ((error != null ? error.code : void 0) === 'ER_DUP_ENTRY') {
          key = error.message.match(/for key '([^']*)'/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        if (result != null ? result.insertId : void 0) {
          return callback(null, result.insertId);
        } else {
          return callback(new Error('unexpected result'));
        }
      });
    };

    /*
      # Updates a record
      # @param {String} model
      # @param {Object} data
      # @param {Function} callback
      # @param {Error} callback.error
    */


    MySQLAdapter.prototype.update = function(model, data, callback) {
      var table;
      table = tableize(model);
      return this._query("UPDATE " + table + " SET ? WHERE id=?", [data, data.id], function(error) {
        var key;
        if ((error != null ? error.code : void 0) === 'ER_DUP_ENTRY') {
          key = error.message.match(/for key '([^']*)'/);
          return callback(new Error('duplicated ' + (key != null ? key[1] : void 0)));
        }
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null);
      });
    };

    MySQLAdapter.prototype._convertToModelInstance = function(model, data) {
      var field, modelClass, property, record, _ref;
      modelClass = this._connection.models[model];
      record = new modelClass();
      record.id = Number(data.id);
      _ref = modelClass._schema;
      for (field in _ref) {
        property = _ref[field];
        if (property.type === DBModel.ForeignKey) {
          record[field] = Number(data[field]);
        } else {
          record[field] = data[field];
        }
      }
      return record;
    };

    /*
      # Finds a record by id
      # @param {String} model
      # @param {String} id
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {DBModel} callback.record
      # @throws Error('not found')
    */


    MySQLAdapter.prototype.findById = function(model, id, callback) {
      var table,
        _this = this;
      table = tableize(model);
      return this._query("SELECT * FROM " + table + " WHERE id=? LIMIT 1", id, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        if ((result != null ? result.length : void 0) === 1) {
          return callback(null, _this._convertToModelInstance(model, result[0]));
        } else if ((result != null ? result.length : void 0) > 1) {
          return callback(new Error('unknown error'));
        } else {
          return callback(new Error('not found'));
        }
      });
    };

    /*
      # Finds records
      # @param {String} model
      # @param {Object} conditions
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {Array<DBModel>} callback.records
    */


    MySQLAdapter.prototype.find = function(model, conditions, callback) {
      var keys, params, sql,
        _this = this;
      params = null;
      sql = "SELECT * FROM " + (tableize(model));
      if ((keys = Object.keys(conditions)).length > 0) {
        params = keys.map(function(key) {
          return conditions[key];
        });
        keys = keys.map(function(key) {
          return key + '=?';
        });
        sql += ' WHERE ' + keys.join(' AND ');
      }
      return this._query(sql, params, function(error, result) {
        if (error) {
          return callback(MySQLAdapter.wrapError('unknown error', error));
        }
        return callback(null, result.map(function(instance) {
          return _this._convertToModelInstance(model, instance);
        }));
      });
    };

    /*
      # Creates a MySQL adapter
      # @param {Connection} connection
      # @param {Object} settings
      # @param {String} [settings.host]
      # @param {Number} [settings.port]
      # @param {String} [settings.user]
      # @param {String} [settings.password]
      # @param {String} settings.database
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {MySQLAdapter} callback.adapter
    */


    MySQLAdapter.createAdapter = function(connection, settings, callback) {
      var client;
      client = mysql.createConnection({
        host: settings.host,
        port: settings.port,
        user: settings.user,
        password: settings.password
      });
      return client.connect(function(error) {
        var adapter;
        if (error) {
          return callback(MySQLAdapter.wrapError('failed to connect', error));
        }
        adapter = new MySQLAdapter(connection, client);
        return client.query("USE `" + settings.database + "`", function(error) {
          var msg;
          if (!error) {
            return callback(null, adapter);
          }
          if (error.code === 'ER_BAD_DB_ERROR') {
            return client.query("CREATE DATABASE `" + settings.database + "`", function(error) {
              if (error) {
                return callback(MySQLAdapter.wrapError('unknown error', error));
              }
              return callback(null, adapter);
            });
          } else {
            msg = error.code === 'ER_DBACCESS_DENIED_ERROR' ? "no access right to the database '" + settings.database + "'" : 'unknown error';
            return callback(MySQLAdapter.wrapError(msg, error));
          }
        });
      });
    };

    return MySQLAdapter;

  })(AdapterBase);

  module.exports = MySQLAdapter.createAdapter;

}).call(this);
