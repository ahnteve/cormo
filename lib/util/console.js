// Generated by CoffeeScript 1.9.1
(function() {
  var Connection, Model, Promise, addArgCompleter, coffee, evalCoffee, fs, path, prettyErrorMessage, repl, setupContext, util, vm;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  repl = require('coffee-script/repl');

  vm = require('vm');

  util = require('util');

  Connection = require('../connection');

  Model = require('../model');

  prettyErrorMessage = coffee.helpers.prettyErrorMessage || function(e) {
    return e;
  };

  addArgCompleter = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write((line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  evalCoffee = function(cmd, context, filename, callback) {
    var assign_to;
    cmd = cmd.replace(/\uFF00/g, '\n');
    cmd = cmd.replace(/^\(([\s\S]*)\n\)$/m, '$1');
    if (!cmd) {
      return callback(null);
    }
    if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
      assign_to = RegExp.$1;
    }
    return Promise["try"](function() {
      var defer, js, result;
      if (/[, ]\$$/.test(cmd)) {
        defer = Promise.defer();
        context.$ = defer.callback;
      }
      js = coffee.compile(cmd, {
        filename: filename,
        bare: true
      });
      result = vm.runInThisContext(js, filename);
      if (defer) {
        delete context.$;
        return defer.promise;
      } else {
        return result;
      }
    }).then(function(result) {
      if (assign_to) {
        context[assign_to] = result;
      }
      return callback(null, result);
    })["catch"](function(error) {
      return callback(prettyErrorMessage(error, filename, cmd, true));
    });
  };

  setupContext = function(context, options) {
    var connection, key, model, modelClass, object, ref, ref1;
    context.Connection = Connection;
    context.Model = Model;
    context.connection = connection = Connection.defaultConnection;
    if (connection) {
      ref = connection.models;
      for (model in ref) {
        modelClass = ref[model];
        context[model] = modelClass;
      }
      connection.applySchemas();
    }
    Object.defineProperty(context.console, 'inspect_depth', {
      enumrable: true,
      get: (function(_this) {
        return function() {
          return options.inspect_depth;
        };
      })(this),
      set: (function(_this) {
        return function(value) {
          return options.inspect_depth = value;
        };
      })(this)
    });
    ref1 = exports["public"];
    for (key in ref1) {
      object = ref1[key];
      context[key] = object;
    }
    context.getTimestamp = function(object_id) {
      return new Date(parseInt(object_id.substr(0, 8), 16) * 1000);
    };
  };

  exports["public"] = {};

  exports.startCoffee = function(options) {
    var repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      historyFile: process.env.HOME ? path.join(process.env.HOME, '.cormo_history') : void 0,
      "eval": evalCoffee,
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true,
      useGlobal: true
    });
    addArgCompleter(repl_server);
    setupContext(repl_server.context, options);
    return repl_server;
  };

}).call(this);
