// Generated by CoffeeScript 1.9.3
(function() {
  var Connection, Model, Promise, addArgCompleterCoffee, addArgCompleterJS, addHistoryJS, coffee, evalCoffee, evalJS, fs, getCommandId, path, prettyErrorMessage, repl_coffee, repl_js, setupContext, util, vm;

  coffee = require('coffee-script');

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  repl_coffee = require('coffee-script/repl');

  repl_js = require('repl');

  vm = require('vm');

  util = require('util');

  Connection = require('../connection');

  Model = require('../model');

  setupContext = function(context, options) {
    var connection, key, model, modelClass, object, ref, ref1;
    context.Connection = Connection;
    context.Model = Model;
    context.connection = connection = Connection.defaultConnection;
    if (connection) {
      ref = connection.models;
      for (model in ref) {
        modelClass = ref[model];
        context[model] = modelClass;
      }
      connection.applySchemas();
    }
    Object.defineProperty(context.console, 'inspect_depth', {
      configurable: true,
      enumrable: true,
      get: (function(_this) {
        return function() {
          return options.inspect_depth;
        };
      })(this),
      set: (function(_this) {
        return function(value) {
          return options.inspect_depth = value;
        };
      })(this)
    });
    ref1 = exports["public"];
    for (key in ref1) {
      object = ref1[key];
      context[key] = object;
    }
    context.getTimestamp = function(object_id) {
      return new Date(parseInt(object_id.substr(0, 8), 16) * 1000);
    };
    context.console.measureTime = function(fn) {
      context.console.time('measureTime');
      return Promise.resolve(fn()).tap(function() {
        return context.console.timeEnd('measureTime');
      });
    };
  };

  exports["public"] = {};

  addArgCompleterCoffee = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write((line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  prettyErrorMessage = coffee.helpers.prettyErrorMessage || function(e) {
    return e;
  };

  evalCoffee = function(cmd, context, filename, callback) {
    var assign_to;
    cmd = cmd.replace(/\uFF00/g, '\n');
    cmd = cmd.replace(/^\(([\s\S]*)\n\)$/m, '$1');
    if (!cmd) {
      return callback(null);
    }
    if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
      assign_to = RegExp.$1;
    }
    this.rli.pause();
    return Promise["try"](function() {
      var defer, js, result;
      if (/[, ]\$$/.test(cmd)) {
        defer = Promise.defer();
        context.$ = defer.callback;
      }
      js = coffee.compile(cmd, {
        filename: filename,
        bare: true
      });
      result = vm.runInContext(js, context, filename);
      if (defer) {
        delete context.$;
        return defer.promise;
      } else {
        return result;
      }
    }).then((function(_this) {
      return function(result) {
        if (assign_to) {
          context[assign_to] = result;
        }
        _this.rli.resume();
        return callback(null, result);
      };
    })(this))["catch"]((function(_this) {
      return function(error) {
        _this.rli.resume();
        return callback(prettyErrorMessage(error, filename, cmd, true));
      };
    })(this));
  };

  exports.startCoffee = function(options) {
    var repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl_coffee.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      historyFile: process.env.HOME ? path.join(process.env.HOME, '.cormo_history') : void 0,
      "eval": evalCoffee,
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true
    });
    addArgCompleterCoffee(repl_server);
    setupContext(repl_server.context, options);
    return repl_server;
  };

  addHistoryJS = function(repl, filename, maxSize) {
    var buffer, fd, lastLine, readFd, size, stat;
    lastLine = null;
    try {
      stat = fs.statSync(filename);
      size = Math.min(maxSize, stat.size);
      readFd = fs.openSync(filename, 'r');
      buffer = new Buffer(size);
      fs.readSync(readFd, buffer, 0, size, stat.size - size);
      repl.rli.history = buffer.toString().split('\n').reverse();
      if (stat.size > maxSize) {
        repl.rli.history.pop();
      }
      if (repl.rli.history[0] === '') {
        repl.rli.history.shift();
      }
      repl.rli.historyIndex = -1;
      lastLine = repl.rli.history[0];
    } catch (_error) {}
    fd = fs.openSync(filename, 'a');
    repl.rli.addListener('line', function(code) {
      if (code && code.length && code !== '.history' && lastLine !== code) {
        fs.write(fd, code + "\n");
        return lastLine = code;
      }
    });
    repl.rli.on('exit', function() {
      return fs.close(fd);
    });
    return repl.commands[getCommandId(repl, 'history')] = {
      help: 'Show command history',
      action: function() {
        repl.outputStream.write((repl.rli.history.slice(0).reverse().join('\n')) + "\n");
        return repl.displayPrompt();
      }
    };
  };

  getCommandId = function(repl, commandName) {
    var commandsHaveLeadingDot;
    commandsHaveLeadingDot = repl.commands['.help'] != null;
    if (commandsHaveLeadingDot) {
      return "." + commandName;
    } else {
      return commandName;
    }
  };

  evalJS = function(originalEval) {
    return function(cmd, context, filename, callback) {
      var assign_to;
      if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
        assign_to = RegExp.$1;
      }
      this.rli.pause();
      return originalEval(cmd, context, filename, (function(_this) {
        return function(error, result) {
          if (error) {
            _this.rli.resume();
            return callback(error);
          }
          return Promise.resolve(result).then(function(result) {
            if (assign_to) {
              context[assign_to] = result;
            }
            _this.rli.resume();
            return callback(null, result);
          })["catch"](function(error) {
            _this.rli.resume();
            return callback(error);
          });
        };
      })(this));
    };
  };

  addArgCompleterJS = function(repl_server) {
    var node_completer, rli;
    rli = repl_server.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      line = line.replace(/\(\s*$/, '');
      return node_completer(line, function(error, result) {
        var show_args;
        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl_server["eval"](line, repl_server.context, 'repl', function(error, obj) {
          var argsMatch;
          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write((line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  exports.startJS = function(options) {
    var historyFile, historyMaxInputSize, repl_server;
    options.inspect_depth || (options.inspect_depth = 2);
    if (options.socket) {
      options.socket.columns = 100;
    }
    repl_server = repl_js.start({
      input: options.socket || process.stdin,
      output: options.socket || process.stdout,
      prompt: 'cormo> ',
      writer: function(object) {
        return util.inspect(object, {
          colors: true,
          depth: options.inspect_depth
        });
      },
      terminal: true
    });
    repl_server["eval"] = evalJS(repl_server["eval"]);
    if (process.env.HOME) {
      historyFile = path.join(process.env.HOME, '.cormo_history_js');
    }
    historyMaxInputSize = 10240;
    if (historyFile) {
      addHistoryJS(repl_server, historyFile, historyMaxInputSize);
    }
    addArgCompleterJS(repl_server);
    setupContext(repl_server.context, options);
    return repl_server;
  };

}).call(this);
