// Generated by CoffeeScript 1.4.0
(function() {
  var ColumnProperty, Model, types, util, _, _bindDomain, _use,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require('underscore');

  types = require('./types');

  util = require('./util');

  _bindDomain = function(fn) {
    var d;
    if (d = process.domain) {
      return d.bind(fn);
    } else {
      return fn;
    }
  };

  ColumnProperty = (function() {

    function ColumnProperty() {}

    return ColumnProperty;

  })();

  Model = (function() {

    Model.dirty_tracking = false;

    Model.newModel = function(connection, name, schema) {
      var NewModel, property;
      NewModel = (function(_super) {

        __extends(NewModel, _super);

        function NewModel() {
          return NewModel.__super__.constructor.apply(this, arguments);
        }

        return NewModel;

      })(Model);
      NewModel.connection(connection, name);
      for (name in schema) {
        property = schema[name];
        NewModel.column(name, property);
      }
      return NewModel;
    };

    Model.connection = function(connection, name) {
      if (this.hasOwnProperty('_connection')) {
        throw new Error('Model::connection was called twice');
      }
      if (!name) {
        name = this.name;
      }
      connection.models[name] = this;
      connection[name] = this;
      Object.defineProperty(this, '_connection', {
        value: connection
      });
      Object.defineProperty(this, '_adapter', {
        value: connection._adapter
      });
      Object.defineProperty(this, '_associations', {
        value: {}
      });
      Object.defineProperty(this, '_validators', {
        value: []
      });
      Object.defineProperty(this, '_name', {
        value: name
      });
      Object.defineProperty(this, '_schema_changed', {
        writable: true,
        value: true
      });
      Object.defineProperty(this, '_schema', {
        value: {}
      });
      Object.defineProperty(this, '_intermediate_paths', {
        value: {}
      });
      return Object.defineProperty(this, '_indexes', {
        value: []
      });
    };

    Model._checkConnection = function() {
      if (this.hasOwnProperty('_connection')) {
        return;
      }
      if (!(Model._Connection.defaultConnection != null)) {
        throw new Error('Create a Connection before creating a Model');
      }
      return this.connection(Model._Connection.defaultConnection);
    };

    Model._waitingForReady = function(object, method, args) {
      if (this._connection._waitingForApplyingSchemas(object, method, args)) {
        return true;
      }
      return this._connection._waitingForConnection(object, method, args);
    };

    Model._getKeyType = function(target_connection) {
      if (target_connection == null) {
        target_connection = this._connection;
      }
      if (this._connection === target_connection && target_connection._adapter.key_type_internal) {
        return target_connection._adapter.key_type_internal;
      } else {
        return target_connection._adapter.key_type;
      }
    };

    Model.column = function(path, property) {
      var i, parts, subcolumn, subproperty, type, _i, _ref;
      this._checkConnection();
      if (typeof property === 'object' && !Array.isArray(property) && (!property.type || property.type.type)) {
        for (subcolumn in property) {
          subproperty = property[subcolumn];
          this.column(path + '.' + subcolumn, subproperty);
        }
        return;
      }
      if (this._schema.hasOwnProperty(path)) {
        return;
      }
      if (typeof property === 'function' || typeof property === 'string' || Array.isArray(property)) {
        property = {
          type: property
        };
      }
      if (Array.isArray(property.type)) {
        property.array = true;
        property.type = property.type[0];
      }
      type = types._toCORMOType(property.type);
      if (type === types.RecordID) {
        type = this._getKeyType(property.connection);
        property.record_id = true;
      }
      if (type === types.GeoPoint && !this._adapter.support_geopoint) {
        throw new Error('this adapter does not support GeoPoint');
      }
      parts = path.split('.');
      for (i = _i = 0, _ref = parts.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this._intermediate_paths[parts.slice(0, +i + 1 || 9e9)] = 1;
      }
      property.type = type;
      property._parts = path.split('.');
      property._dbname = path.replace('.', '_');
      this._schema[path] = property;
      this._schema_changed = true;
      return this._connection._schema_changed = true;
    };

    Model.index = function(columns, options) {
      this._checkConnection();
      options || (options = {});
      if (!options.name) {
        options.name = Object.keys(columns).join('_');
      }
      return this._indexes.push({
        columns: columns,
        options: options
      });
    };

    Model.drop = function(callback) {
      var _this = this;
      if (this._connection._waitingForConnection(this, this.drop, arguments)) {
        return;
      }
      return this._adapter.drop(this._name, _bindDomain(function(error) {
        _this._schema_changed = true;
        _this._connection._schema_changed = true;
        return callback(error);
      }));
    };

    Model.build = function(data) {
      return new this(data);
    };

    function Model(data) {
      var adapter, column, ctor, id, last, obj, parts, path, property, schema, support_nested, value, _i, _len, _ref, _ref1, _ref2;
      data = data || {};
      ctor = this.constructor;
      schema = ctor._schema;
      adapter = ctor._adapter;
      Object.defineProperty(this, '_prev_attributes', {
        writable: true,
        value: {}
      });
      if (ctor.dirty_tracking) {
        Object.defineProperty(this, '_attributes', {
          value: {}
        });
        Object.defineProperty(this, '_intermediates', {
          value: {}
        });
        _ref = Object.keys(ctor._intermediate_paths).sort();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          path = _ref[_i];
          _ref1 = util.getLeafOfPath(this, path), obj = _ref1[0], last = _ref1[1];
          this._intermediates[path] = {};
          this._defineProperty(obj, last, path, false);
        }
        for (column in schema) {
          property = schema[column];
          _ref2 = util.getLeafOfPath(this, property._parts), obj = _ref2[0], last = _ref2[1];
          this._defineProperty(obj, last, column, false);
        }
      } else {
        Object.defineProperty(this, 'isDirty', {
          value: function() {
            return true;
          }
        });
        Object.defineProperty(this, 'getChanged', {
          value: function() {
            return [];
          }
        });
        Object.defineProperty(this, 'get', {
          value: function(path) {
            return util.getPropertyOfPath(this, path.split('.'));
          }
        });
        Object.defineProperty(this, 'getPrevious', {
          value: function() {}
        });
        Object.defineProperty(this, 'set', {
          value: function(path, value) {
            return util.setPropertyOfPath(this, path.split('.'), value);
          }
        });
        Object.defineProperty(this, 'reset', {
          value: function() {}
        });
      }
      if (id = arguments[1]) {
        support_nested = adapter.support_nested;
        for (column in schema) {
          property = schema[column];
          parts = property._parts;
          value = support_nested ? util.getPropertyOfPath(data, parts) : data[property._dbname];
          if (value != null) {
            value = adapter.valueToModel(value, column, property);
            util.setPropertyOfPath(this, parts, value);
          }
        }
        Object.defineProperty(this, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: id
        });
        this._runCallbacks('find', 'after');
      } else {
        for (column in schema) {
          property = schema[column];
          parts = property._parts;
          value = util.getPropertyOfPath(data, parts);
          if (value != null) {
            util.setPropertyOfPath(this, parts, value);
          }
        }
        Object.defineProperty(this, 'id', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: void 0
        });
      }
      this._runCallbacks('initialize', 'after');
    }

    Model.prototype._defineProperty = function(object, key, path, enumerable) {
      var _this = this;
      return Object.defineProperty(object, key, {
        configurable: true,
        enumerable: enumerable,
        get: function() {
          return _this.get(path);
        },
        set: function(value) {
          return _this.set(path, value);
        }
      });
    };

    Model.prototype.isDirty = function() {
      return Object.keys(this._prev_attributes).length > 0;
    };

    Model.prototype.getChanged = function() {
      return Object.keys(this._prev_attributes);
    };

    Model.prototype.get = function(path) {
      if (this._intermediates.hasOwnProperty(path)) {
        return this._intermediates[path];
      } else {
        return util.getPropertyOfPath(this._attributes, path);
      }
    };

    Model.prototype.getPrevious = function(path) {
      return this._prev_attributes[path];
    };

    Model.prototype.set = function(path, value) {
      var k, last, obj, parts, prev_value, v, _ref, _ref1, _results, _results1;
      if (this._intermediates.hasOwnProperty(path)) {
        obj = this._intermediates[path];
        for (k in obj) {
          obj[k] = void 0;
        }
        _results = [];
        for (k in value) {
          v = value[k];
          _results.push(obj[k] = v);
        }
        return _results;
      } else {
        parts = path.split('.');
        prev_value = util.getPropertyOfPath(this._attributes, parts);
        if (prev_value === value) {
          return;
        }
        if (!this._prev_attributes.hasOwnProperty(path)) {
          this._prev_attributes[path] = prev_value;
        }
        _ref = util.getLeafOfPath(this, parts), obj = _ref[0], last = _ref[1];
        this._defineProperty(obj, last, path, value != null);
        util.setPropertyOfPath(this._attributes, parts, value);
        _results1 = [];
        while (parts.length > 1) {
          parts.pop();
          _ref1 = util.getLeafOfPath(this, parts), obj = _ref1[0], last = _ref1[1];
          _results1.push(this._defineProperty(obj, last, parts.join('.'), true));
        }
        return _results1;
      }
    };

    Model.prototype.reset = function() {
      var path, value, _ref;
      _ref = this._prev_attributes;
      for (path in _ref) {
        value = _ref[path];
        this.set(path, value);
      }
      return this._prev_attributes = {};
    };

    Model.prototype.destroy = function(callback) {
      var _this = this;
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this._runCallbacks('destroy', 'before');
      if (this.id) {
        this.constructor["delete"]({
          id: this.id
        }, function(error, count) {
          _this._runCallbacks('destroy', 'after');
          return callback(error);
        });
      } else {
        this._runCallbacks('destroy', 'after');
        callback(null);
      }
    };

    Model.deleteAll = function(callback) {
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this["delete"](callback);
    };

    Model.hasMany = function(target_model_or_column, options) {
      this._checkConnection();
      return this._connection.addAssociation({
        type: 'hasMany',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.belongsTo = function(target_model_or_column, options) {
      this._checkConnection();
      return this._connection.addAssociation({
        type: 'belongsTo',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    return Model;

  })();

  _use = function(file) {
    var MixClass;
    MixClass = require("./model/" + file);
    _.extend(Model, MixClass);
    return _.extend(Model.prototype, MixClass.prototype);
  };

  _use('query');

  _use('callback');

  _use('timestamp');

  _use('persistence');

  _use('validate');

  module.exports = Model;

}).call(this);
