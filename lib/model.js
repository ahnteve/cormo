// Generated by CoffeeScript 1.3.3
(function() {
  var DBModel, DBQuery, async, inflector, _normalizeSchema,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inflector = require('./inflector');

  async = require('async');

  DBQuery = require('./query');

  /*
  # Normalizes a schema
  # (column: String -> column: {type: String})
  */


  _normalizeSchema = function(schema) {
    var column, property;
    for (column in schema) {
      property = schema[column];
      if (typeof property === 'function') {
        schema[column] = {
          type: property
        };
      }
    }
  };

  /*
  # Base class for models
  */


  DBModel = (function() {

    DBModel.String = String;

    DBModel.Number = Number;

    DBModel.ForeignKey = function() {};

    /*
      # Returns a new model class extending DBModel
      # @param {DBConnection} connection
      # @param {String} name
      # @param {Object} schema
      # @return {Class}
    */


    DBModel.newModel = function(connection, name, schema) {
      var NewModel;
      _normalizeSchema(schema);
      NewModel = (function(_super) {

        __extends(NewModel, _super);

        function NewModel() {
          return NewModel.__super__.constructor.apply(this, arguments);
        }

        return NewModel;

      })(DBModel);
      Object.defineProperty(NewModel, '_connection', {
        value: connection
      });
      Object.defineProperty(NewModel, '_name', {
        value: name
      });
      Object.defineProperty(NewModel, '_schema', {
        value: schema
      });
      Object.defineProperty(NewModel, '_associations', {
        value: {}
      });
      Object.defineProperty(NewModel, '_validators', {
        value: []
      });
      return NewModel;
    };

    /*
      # Creates a record
      # @param {Object} [data={}]
    */


    function DBModel(data) {
      var schema,
        _this = this;
      data = data || {};
      schema = this.constructor._schema;
      Object.keys(schema).forEach(function(column) {
        if (data[column] != null) {
          return _this[column] = data[column];
        }
      });
      Object.defineProperty(this, 'id', {
        configurable: true,
        enumerable: true,
        writable: false,
        value: void 0
      });
    }

    /*
      # Creates a record.
      # 'Model.build(data)' is the same as 'new Model(data)'
      # @param {Object} [data={}]
      # @return {DBModel}
    */


    DBModel.build = function(data) {
      return new this(data);
    };

    /*
      # Creates a record and saves it to the database
      # 'Model.create(data, callback)' is the same as 'Model.build(data).save(callback)'
      # @param {Object} [data={}]
      # @param {Function} callback
      # @param {Error} callback.error
      # @param {DBModel} callback.record created record
    */


    DBModel.create = function(data, callback) {
      if (typeof data === 'function') {
        callback = data;
        data = {};
      }
      return this.build(data).save(callback);
    };

    /*
      # Validates data
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @return {Boolean}
    */


    DBModel.prototype.validate = function(callback) {
      var errors, schema,
        _this = this;
      errors = [];
      schema = this.constructor._schema;
      Object.keys(schema).forEach(function(column) {
        var property, value;
        property = schema[column];
        if (property.required && !(_this[column] != null)) {
          errors.push("'" + column + "' is required");
        }
        if (property.type === DBModel.Number && (_this[column] != null)) {
          value = Number(_this[column]);
          if (isNaN(value)) {
            return errors.push("'" + column + "' is not a number");
          } else {
            return _this[column] = value;
          }
        }
      });
      this.constructor._validators.forEach(function(validator) {
        var r;
        try {
          r = validator(_this);
          if (r === false) {
            return errors.push('validation failed');
          } else if (typeof r === 'string') {
            return errors.push(r);
          }
        } catch (e) {
          return errors.push(e.message);
        }
      });
      if (errors.length > 0) {
        if (typeof callback === "function") {
          callback(new Error(errors.join(',')));
        }
        return false;
      } else {
        if (typeof callback === "function") {
          callback(null);
        }
        return true;
      }
    };

    DBModel.prototype._buildSaveData = function() {
      var data, schema,
        _this = this;
      data = {};
      schema = this.constructor._schema;
      Object.keys(schema).forEach(function(column) {
        if (_this[column] != null) {
          return data[column] = _this[column];
        } else {
          return data[column] = null;
        }
      });
      return data;
    };

    DBModel.prototype._create = function(callback) {
      var ctor, data,
        _this = this;
      ctor = this.constructor;
      data = this._buildSaveData();
      if (Object.keys(data).length === 0) {
        return callback(new Error('empty data', this));
      }
      return ctor._connection._adapter.create(ctor._name, data, function(error, id) {
        var foreign_key;
        if (error) {
          return callback(error, _this);
        }
        Object.defineProperty(_this, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: id
        });
        foreign_key = inflector.foreign_key(ctor._name);
        return async.forEach(Object.keys(ctor._associations), function(column, callback) {
          return async.forEach(_this['__cache_' + column] || [], function(sub, callback) {
            sub[foreign_key] = id;
            return sub.save(function(error) {
              return callback(error);
            });
          }, function(error) {
            return callback(error);
          });
        }, function(error) {
          return callback(null, _this);
        });
      });
    };

    DBModel.prototype._update = function(callback) {
      var ctor, data,
        _this = this;
      ctor = this.constructor;
      data = this._buildSaveData();
      data.id = this.id;
      return ctor._connection._adapter.update(ctor._name, data, function(error) {
        if (error) {
          return callback(error, _this);
        }
        return callback(null, _this);
      });
    };

    /*
      # Saves data to the database
      # @param {Object} [options]
      # @param {Boolean} [options.validate=true]
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @param {DBModel} callback.record this
    */


    DBModel.prototype.save = function(options, callback) {
      var _this = this;
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      if ((options != null ? options.validate : void 0) !== false) {
        this.validate(function(error) {
          if (error) {
            return callback(error);
          }
          return _this.save({
            validate: false
          }, callback);
        });
        return;
      }
      if (this.id) {
        return this._update(callback);
      } else {
        return this._create(callback);
      }
    };

    /*
      # Destroys this record (remove from the database)
      # @param {Function} callback
      # @param {Error} callback.error
    */


    DBModel.prototype.destroy = function(callback) {
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this.constructor["delete"]({
        id: this.id
      }, callback);
    };

    /*
      # Finds a record by id
      # @param {String} id
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @param {DBModel} callback.record
      # @return {DBQuery}
      # @throws Error('not found')
    */


    DBModel.find = function(id, callback) {
      var query;
      query = new DBQuery(this);
      query.find(id);
      if (typeof callback === 'function') {
        query.exec(function(error, records) {
          if ((records != null ? records.length : void 0) === 0) {
            error = new Error('not found');
          }
          if ((records != null ? records.length : void 0) > 1) {
            error = new Error('unknown error');
          }
          if (error) {
            return callback(error);
          }
          return callback(null, records[0]);
        });
      }
      return query;
    };

    /*
      # Finds records by conditions
      # @param {Object} [condition]
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @param {Array<DBModel>} callback.records
      # @return {DBQuery}
    */


    DBModel.where = function(condition, callback) {
      var query;
      if (typeof condition === 'function') {
        callback = condition;
        condition = null;
      }
      query = new DBQuery(this);
      query.where(condition);
      if (typeof callback === 'function') {
        query.exec(callback);
      }
      return query;
    };

    /*
      # Counts records by conditions
      # @param {Object} [condition]
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @param {Number} callback.count
      # @return {DBQuery}
    */


    DBModel.count = function(condition, callback) {
      var query;
      if (typeof condition === 'function') {
        callback = condition;
        condition = null;
      }
      query = new DBQuery(this);
      query.where(condition);
      if (typeof callback === 'function') {
        query.count(callback);
      }
      return query;
    };

    /*
      # Deletes records by conditions
      # @param {Object} [condition]
      # @param {Function} [callback]
      # @param {Error} callback.error
      # @param {Number} callback.count
      # @return {DBQuery}
    */


    DBModel["delete"] = function(condition, callback) {
      var query;
      if (typeof condition === 'function') {
        callback = condition;
        condition = null;
      }
      query = new DBQuery(this);
      query.where(condition);
      if (typeof callback === 'function') {
        query["delete"](callback);
      }
      return query;
    };

    /*
      # Adds a has-many association
      # @param {Class} target_model
      # @param {Object} [options]
      # @param {String} [options.as]
      # @param {String} [options.foreign_key]
    */


    DBModel.hasMany = function(target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(this._name);
      }
      target_model._addForeignKey(foreign_key);
      column = (options != null ? options.as : void 0) || inflector.tableize(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      this._associations[column] = {
        type: 'hasMany'
      };
      return Object.defineProperty(this.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var conditions, self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self.id) {
                conditions = {};
                conditions[foreign_key] = self.id;
                return target_model.where(conditions, function(error, records) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = records;
                  return callback(null, records);
                });
              } else {
                return callback(null, self[columnCache] || []);
              }
            };
            getter.build = function(data) {
              var new_object, self;
              self = getter.__scope;
              new_object = new target_model(data);
              new_object[foreign_key] = self.id;
              if (!self[columnCache]) {
                self[columnCache] = [];
              }
              self[columnCache].push(new_object);
              return new_object;
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    /*
      # Adds a belongs-to association
      # @param {Class} target_model
      # @param {Object} [options]
      # @param {String} [options.as]
      # @param {String} [options.foreign_key]
    */


    DBModel.belongsTo = function(target_model, options) {
      var column, columnCache, columnGetter, foreign_key;
      if (options != null ? options.foreign_key : void 0) {
        foreign_key = options.foreign_key;
      } else if (options != null ? options.as : void 0) {
        foreign_key = options.as + '_id';
      } else {
        foreign_key = inflector.foreign_key(target_model._name);
      }
      this._addForeignKey(foreign_key);
      column = (options != null ? options.as : void 0) || inflector.underscore(target_model._name);
      columnCache = '__cache_' + column;
      columnGetter = '__getter_' + column;
      return Object.defineProperty(this.prototype, column, {
        get: function() {
          var getter;
          if (!this.hasOwnProperty(columnGetter)) {
            getter = function(reload, callback) {
              var self;
              if (typeof reload === 'function') {
                callback = reload;
                reload = false;
              }
              self = getter.__scope;
              if ((!self[columnCache] || reload) && self[foreign_key]) {
                return target_model.find(self[foreign_key], function(error, record) {
                  if (error) {
                    return callback(error);
                  }
                  self[columnCache] = record;
                  return callback(null, record);
                });
              } else {
                return callback(null, self[columnCache]);
              }
            };
            getter.__scope = this;
            Object.defineProperty(this, columnCache, {
              value: null,
              writable: true
            });
            Object.defineProperty(this, columnGetter, {
              value: getter
            });
          }
          return this[columnGetter];
        }
      });
    };

    /*
      # Adds a validator
      #
      # A validator must return false(boolean) or error message(string), or throw an Error exception if invalid
      # @param {Function} validator
      # @param {DBModel} validator.record
    */


    DBModel.addValidator = function(validator) {
      return this._validators.push(validator);
    };

    /*
      # Drops this model from the database
      # @param {Function} callback
      # @param {Error} callback.error
    */


    DBModel.drop = function(callback) {
      return this._connection._adapter.drop(this._name, callback);
    };

    /*
      # Deletes all records from the database
      # @param {Function} callback
      # @param {Error} callback.error
    */


    DBModel.deleteAll = function(callback) {
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this["delete"](callback);
    };

    DBModel._addForeignKey = function(column) {
      if (this._schema.hasOwnProperty(column)) {
        return;
      }
      return this._schema[column] = {
        type: this.ForeignKey
      };
    };

    return DBModel;

  })();

  module.exports = DBModel;

}).call(this);
