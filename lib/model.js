// Generated by CoffeeScript 1.4.0
(function() {
  var Model, ModelCallback, ModelQuery, async, inflector, type, value, _, _getRef, _getValue, _ref, _setValue,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inflector = require('./inflector');

  async = require('async');

  _ = require('underscore');

  _getRef = function(obj, parts) {
    var last, part, _i, _len;
    if (parts.length === 1) {
      return [obj, parts[0]];
    }
    parts = parts.slice(0);
    last = parts.pop();
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      obj = obj[part] || (obj[part] = {});
    }
    return [obj, last];
  };

  _getValue = function(obj, parts) {
    var part, _i, _len;
    if (parts.length === 1) {
      return obj[parts[0]];
    }
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      obj = obj[part];
      if (!obj) {
        break;
      }
    }
    return obj;
  };

  _setValue = function(obj, parts, value) {
    var last, _ref;
    _ref = _getRef(obj, parts), obj = _ref[0], last = _ref[1];
    obj[last] = value;
  };

  Model = (function() {

    Model.newModel = function(connection, name, schema) {
      var NewModel, property;
      NewModel = (function(_super) {

        __extends(NewModel, _super);

        function NewModel() {
          return NewModel.__super__.constructor.apply(this, arguments);
        }

        return NewModel;

      })(Model);
      NewModel.connection(connection, name);
      for (name in schema) {
        property = schema[name];
        NewModel.column(name, property);
      }
      return NewModel;
    };

    Model.connection = function(connection, name) {
      if (!name) {
        name = this.name;
      }
      connection.models[name] = this;
      Object.defineProperty(this, '_connection', {
        value: connection
      });
      Object.defineProperty(this, '_adapter', {
        value: connection._adapter
      });
      Object.defineProperty(this, '_associations', {
        value: {}
      });
      Object.defineProperty(this, '_validators', {
        value: []
      });
      Object.defineProperty(this, '_name', {
        configurable: true,
        value: name
      });
      return Object.defineProperty(this, '_schema', {
        configurable: true,
        value: {}
      });
    };

    Model.column = function(name, property) {
      var subproperty, subtype, target_connection, type;
      if (typeof property === 'object' && (!property.type || property.type.type)) {
        for (subtype in property) {
          subproperty = property[subtype];
          this.column(name + '.' + subtype, subproperty);
        }
        return;
      }
      if (this._schema.hasOwnProperty(name)) {
        return;
      }
      if (typeof property === 'function' || typeof property === 'string') {
        property = {
          type: property
        };
      }
      type = property.type;
      switch (type) {
        case String:
          type = Model.String;
          break;
        case Number:
          type = Model.Number;
          break;
        case Boolean:
          type = Model.Boolean;
          break;
        case Date:
          type = Model.Date;
          break;
        case Object:
          type = Model.Object;
      }
      if (typeof type !== 'string') {
        throw new Error('unknown type : ' + type);
      }
      type = type.toLowerCase();
      if (type === Model.GeoPoint && !this._adapter.support_geopoint) {
        throw new Error('this adapter does not support GeoPoint');
      }
      if (type === Model.RecordID) {
        target_connection = property.connection || this._connection;
        if (this._connection === target_connection && target_connection._adapter.key_type_internal) {
          type = target_connection._adapter.key_type_internal;
        } else {
          type = target_connection._adapter.key_type;
        }
      }
      property.type = type;
      property.parts = name.split('.');
      if (!this._adapter.support_nested) {
        property.dbname = name.replace('.', '_');
      }
      return this._schema[name] = property;
    };

    Model._waitingForConnection = function(object, method, args) {
      if (this._connection._waitingForApplyingSchemas(object, method, args)) {
        return true;
      }
      return this._connection._waitingForConnection(object, method, args);
    };

    function Model(data) {
      var adapter, column, ctor, id, parts, property, schema, value;
      data = data || {};
      ctor = this.constructor;
      schema = ctor._schema;
      adapter = ctor._adapter;
      if (id = arguments[1]) {
        for (column in schema) {
          property = schema[column];
          parts = property.parts;
          if (adapter.support_nested) {
            value = _getValue(data, parts);
          } else {
            value = data[property.dbname];
          }
          if (value != null) {
            if (property.type === Model.Object && !adapter.support_object) {
              value = JSON.parse(value);
            } else {
              value = adapter.valueToModel(value, column, property);
            }
            _setValue(this, parts, value);
          }
        }
        Object.defineProperty(this, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: id
        });
        this._runCallbacks('find', 'after');
      } else {
        for (column in schema) {
          property = schema[column];
          parts = property.parts;
          value = _getValue(data, parts);
          if (value != null) {
            _setValue(this, parts, value);
          }
        }
        Object.defineProperty(this, 'id', {
          configurable: true,
          enumerable: true,
          writable: false,
          value: void 0
        });
      }
      this._runCallbacks('initialize', 'after');
    }

    Model.build = function(data) {
      return new this(data);
    };

    Model.create = function(data, callback) {
      if (typeof data === 'function') {
        callback = data;
        data = {};
      }
      return this.build(data).save(callback);
    };

    Model.prototype.validate = function(callback) {
      var column, errors, last, obj, property, schema, value, _ref,
        _this = this;
      this._runCallbacks('validate', 'before');
      errors = [];
      schema = this.constructor._schema;
      for (column in schema) {
        property = schema[column];
        _ref = _getRef(this, property.parts), obj = _ref[0], last = _ref[1];
        value = obj[last];
        if (value != null) {
          switch (property.type) {
            case Model.Number:
              value = Number(value);
              if (isNaN(value)) {
                errors.push("'" + column + "' is not a number");
              } else {
                obj[last] = value;
              }
              break;
            case Model.Boolean:
              if (typeof value !== 'boolean') {
                errors.push("'" + column + "' is not a boolean");
              }
              break;
            case Model.Integer:
              value = Number(value);
              if (isNaN(value) || (value >> 0) !== value) {
                errors.push("'" + column + "' is not an integer");
              } else {
                obj[last] = value;
              }
              break;
            case Model.GeoPoint:
              if (!(Array.isArray(value) && value.length === 2)) {
                errors.push("'" + column + "' is not a geo point");
              } else {
                value[0] = Number(value[0]);
                value[1] = Number(value[1]);
              }
              break;
            case Model.Date:
              value = new Date(value);
              if (isNaN(value.getTime())) {
                errors.push("'" + column + "' is not a date");
              } else {
                obj[last] = value;
              }
          }
        } else {
          if (property.required) {
            errors.push("'" + column + "' is required");
          }
        }
      }
      this.constructor._validators.forEach(function(validator) {
        var r;
        try {
          r = validator(_this);
          if (r === false) {
            return errors.push('validation failed');
          } else if (typeof r === 'string') {
            return errors.push(r);
          }
        } catch (e) {
          return errors.push(e.message);
        }
      });
      if (errors.length > 0) {
        this._runCallbacks('validate', 'after');
        if (typeof callback === "function") {
          callback(new Error(errors.join(',')));
        }
        return false;
      } else {
        this._runCallbacks('validate', 'after');
        if (typeof callback === "function") {
          callback(null);
        }
        return true;
      }
    };

    Model.prototype._buildSaveData = function() {
      var adapter, column, ctor, data, parts, property, schema, value;
      data = {};
      ctor = this.constructor;
      schema = ctor._schema;
      adapter = ctor._adapter;
      for (column in schema) {
        property = schema[column];
        parts = property.parts;
        value = _getValue(this, parts);
        if (property.type === Model.Object && !adapter.support_object) {
          value = JSON.stringify(value);
        } else {
          value = adapter.valueToDB(value, column, property);
        }
        if (value !== void 0) {
          if (adapter.support_nested) {
            _setValue(data, parts, value);
          } else {
            data[property.dbname] = value;
          }
        }
      }
      if (this.id != null) {
        data.id = adapter.idToDB(this.id);
      }
      return data;
    };

    Model.prototype._create = function(callback) {
      var ctor, data,
        _this = this;
      if (this.constructor._waitingForConnection(this, this._create, arguments)) {
        return;
      }
      try {
        data = this._buildSaveData();
      } catch (e) {
        return callback(e, this);
      }
      if (Object.keys(data).length === 0) {
        return callback(new Error('empty data', this));
      }
      ctor = this.constructor;
      return ctor._adapter.create(ctor._name, data, function(error, id) {
        var foreign_key;
        if (error) {
          return callback(error, _this);
        }
        Object.defineProperty(_this, 'id', {
          configurable: false,
          enumerable: true,
          writable: false,
          value: id
        });
        foreign_key = inflector.foreign_key(ctor._name);
        return async.forEach(Object.keys(ctor._associations), function(column, callback) {
          return async.forEach(_this['__cache_' + column] || [], function(sub, callback) {
            sub[foreign_key] = id;
            return sub.save(function(error) {
              return callback(error);
            });
          }, function(error) {
            return callback(error);
          });
        }, function(error) {
          return callback(null, _this);
        });
      });
    };

    Model.prototype._update = function(callback) {
      var ctor, data,
        _this = this;
      if (this.constructor._waitingForConnection(this, this._update, arguments)) {
        return;
      }
      try {
        data = this._buildSaveData();
      } catch (e) {
        return callback(e, this);
      }
      ctor = this.constructor;
      return ctor._adapter.update(ctor._name, data, function(error) {
        if (error) {
          return callback(error, _this);
        }
        return callback(null, _this);
      });
    };

    Model.prototype.save = function(options, callback) {
      var _this = this;
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      if ((options != null ? options.validate : void 0) !== false) {
        this.validate(function(error) {
          if (error) {
            return callback(error);
          }
          return _this.save({
            validate: false
          }, callback);
        });
        return;
      }
      this._runCallbacks('save', 'before');
      if (this.id) {
        this._runCallbacks('update', 'before');
        return this._update(function(error, record) {
          _this._runCallbacks('update', 'after');
          _this._runCallbacks('save', 'after');
          return callback(error, record);
        });
      } else {
        this._runCallbacks('create', 'before');
        return this._create(function(error, record) {
          _this._runCallbacks('create', 'after');
          _this._runCallbacks('save', 'after');
          return callback(error, record);
        });
      }
    };

    Model.prototype.destroy = function(callback) {
      var _this = this;
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this._runCallbacks('destroy', 'before');
      if (this.id) {
        this.constructor["delete"]({
          id: this.id
        }, function(error, count) {
          _this._runCallbacks('destroy', 'after');
          return callback(error);
        });
      } else {
        this._runCallbacks('destroy', 'after');
        callback(null);
      }
    };

    Model.hasMany = function(target_model_or_column, options) {
      return this._connection._pending_associations.push({
        type: 'hasMany',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.belongsTo = function(target_model_or_column, options) {
      return this._connection._pending_associations.push({
        type: 'belongsTo',
        this_model: this,
        target_model_or_column: target_model_or_column,
        options: options
      });
    };

    Model.addValidator = function(validator) {
      return this._validators.push(validator);
    };

    Model.drop = function(callback) {
      if (this._waitingForConnection(this, this.drop, arguments)) {
        return;
      }
      return this._adapter.drop(this._name, callback);
    };

    Model.deleteAll = function(callback) {
      if (typeof callback !== 'function') {
        callback = (function() {});
      }
      this["delete"](callback);
    };

    return Model;

  })();

  ModelQuery = require('./model/query');

  _.extend(Model, ModelQuery);

  _.extend(Model.prototype, ModelQuery.prototype);

  ModelCallback = require('./model/callback');

  _.extend(Model, ModelCallback);

  _.extend(Model.prototype, ModelCallback.prototype);

  _ref = require('./types');
  for (type in _ref) {
    value = _ref[type];
    Model[type] = value;
    Model.prototype[type] = value;
  }

  module.exports = Model;

}).call(this);
