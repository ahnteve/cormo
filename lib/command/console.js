// Generated by CoffeeScript 1.6.2
(function() {
  var CommandConsole, Connection, Fiber, Future, Model, Query, addArgCompleter, addHistory, addMultilineHandler, coffee, commander, console_future, fs, path, prettyErrorMessage, repl, util, vm;

  coffee = require('coffee-script');

  commander = require('commander');

  Fiber = require('fibers');

  Future = require('fibers/future');

  path = require('path');

  repl = require('repl');

  vm = require('vm');

  fs = require('fs');

  util = require('util');

  Connection = require('../connection');

  Model = require('../model');

  Query = require('../query');

  console_future = require('../console_future');

  console_future.execute = function(callback, func) {
    var future;

    if (typeof callback !== 'function') {
      future = new Future();
      callback = future.resolver();
    }
    func(callback);
    if (future) {
      return future.wait();
    }
  };

  prettyErrorMessage = coffee.helpers.prettyErrorMessage || function(e) {
    return e;
  };

  addMultilineHandler = function(repl) {
    var inputStream, multiline, nodeLineListener, outputStream, rli;

    rli = repl.rli, inputStream = repl.inputStream, outputStream = repl.outputStream;
    multiline = {
      enabled: false,
      initialPrompt: repl.prompt.replace(/^[^> ]*/, function(x) {
        return x.replace(/./g, '-');
      }),
      prompt: repl.prompt.replace(/^[^> ]*>?/, function(x) {
        return x.replace(/./g, '.');
      }),
      buffer: ''
    };
    nodeLineListener = rli.listeners('line')[0];
    rli.removeListener('line', nodeLineListener);
    rli.on('line', function(cmd) {
      if (multiline.enabled) {
        multiline.buffer += "" + cmd + "\n";
        rli.setPrompt(multiline.prompt);
        rli.prompt(true);
      } else {
        nodeLineListener(cmd);
      }
    });
    return inputStream.on('keypress', function(char, key) {
      if (!(key && key.ctrl && !key.meta && !key.shift && key.name === 'v')) {
        return;
      }
      if (multiline.enabled) {
        if (!multiline.buffer.match(/\n/)) {
          multiline.enabled = !multiline.enabled;
          rli.setPrompt(repl.prompt);
          rli.prompt(true);
          return;
        }
        if ((rli.line != null) && !rli.line.match(/^\s*$/)) {
          return;
        }
        multiline.enabled = !multiline.enabled;
        rli.line = '';
        rli.cursor = 0;
        rli.output.cursorTo(0);
        rli.output.clearLine(1);
        multiline.buffer = multiline.buffer.replace(/\n/g, '\uFF00');
        rli.emit('line', multiline.buffer);
        multiline.buffer = '';
      } else {
        multiline.enabled = !multiline.enabled;
        rli.setPrompt(multiline.initialPrompt);
        rli.prompt(true);
      }
    });
  };

  addHistory = function(repl, filename, maxSize) {
    var buffer, fd, lastLine, readFd, size, stat;

    lastLine = null;
    try {
      stat = fs.statSync(filename);
      size = Math.min(maxSize, stat.size);
      readFd = fs.openSync(filename, 'r');
      buffer = new Buffer(size);
      fs.readSync(readFd, buffer, 0, size, stat.size - size);
      repl.rli.history = buffer.toString().split('\n').reverse();
      if (stat.size > maxSize) {
        repl.rli.history.pop();
      }
      if (repl.rli.history[0] === '') {
        repl.rli.history.shift();
      }
      repl.rli.historyIndex = -1;
      lastLine = repl.rli.history[0];
    } catch (_error) {}
    fd = fs.openSync(filename, 'a');
    repl.rli.addListener('line', function(code) {
      if (code && code.length && code !== '.history' && lastLine !== code) {
        fs.write(fd, "" + code + "\n");
        return lastLine = code;
      }
    });
    repl.rli.on('exit', function() {
      return fs.close(fd);
    });
    return repl.commands['.history'] = {
      help: 'Show command history',
      action: function() {
        repl.outputStream.write("" + (repl.rli.history.slice(0).reverse().join('\n')) + "\n");
        return repl.displayPrompt();
      }
    };
  };

  addArgCompleter = function(repl) {
    var node_completer, rli;

    rli = repl.rli;
    node_completer = rli.completer;
    return rli.completer = function(line, callback) {
      return node_completer(line, function(error, result) {
        var show_args;

        show_args = true;
        if (error || !result[0]) {
          show_args = false;
        } else if (result[0].length > 1) {
          show_args = false;
        } else if (result[0].length === 1 && result[0][0] !== result[1]) {
          show_args = false;
        } else if (!/^[A-Za-z0-9_.]+\s*$/.test(line)) {
          show_args = false;
        }
        if (!show_args) {
          return callback(error, result);
        }
        return repl["eval"](line, repl.context, 'repl', function(error, obj) {
          var argsMatch;

          if (typeof obj === 'function') {
            rli.output.write('\r\n');
            argsMatch = obj.toString().match(/^function\s*[^\(]*\(\s*([^\)]*)\)/m);
            rli.output.write("" + (line.trim()) + " \u001b[35m" + argsMatch[1] + "\u001b[39m\r\n");
            rli._refreshLine();
          }
          return callback(error, result);
        });
      });
    };
  };

  CommandConsole = (function() {
    function CommandConsole(argv) {
      var cwd, e, load, loads, program, _i, _len,
        _this = this;

      loads = [];
      this.inspect_depth = 2;
      this.program = program = new commander.Command('cormo');
      program.usage('console [options]').option('-l, --load <path>', 'load specified module').option('-d, --inspect-depth <depth>', 'specify depth for util.inspect').on('load', function(path) {
        return loads.push(path);
      }).on('inspect-depth', function(depth) {
        return _this.inspect_depth = depth;
      });
      if (argv.indexOf('--help') >= 0 || argv.indexOf('-h') >= 0) {
        program.help();
      }
      program.parse(argv);
      cwd = process.cwd();
      for (_i = 0, _len = loads.length; _i < _len; _i++) {
        load = loads[_i];
        console.log("Loading module '" + load + "'...");
        try {
          require(load);
        } catch (_error) {
          e = _error;
          try {
            require(path.resolve(cwd, load));
          } catch (_error) {
            e = _error;
          }
        }
      }
    }

    CommandConsole.prototype.run = function() {
      return this.runCoffee();
    };

    CommandConsole.prototype.runCoffee = function() {
      var historyFile,
        _this = this;

      repl = repl.start({
        prompt: 'cormo> ',
        "eval": function(cmd, context, filename, callback) {
          return Fiber(function() {
            var assign_to, e, future, js, result, use_future;

            cmd = cmd.replace(/\uFF00/g, '\n');
            cmd = cmd.replace(/^\(([\s\S]*)\n\)$/m, '$1');
            if (!cmd) {
              return callback(null);
            }
            use_future = /[, ]\$$/.test(cmd);
            if (use_future) {
              future = new Future();
              context.$ = future.resolver();
            }
            if (/^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s=/.test(cmd)) {
              assign_to = RegExp.$1;
            }
            try {
              js = coffee.compile(cmd, {
                filename: filename,
                bare: true
              });
              result = vm.runInContext(js, context, filename);
              if (use_future) {
                result = future.wait();
                if (assign_to) {
                  context[assign_to] = result;
                }
                delete context.$;
              } else if (result instanceof Query) {
                future = new Future();
                result.exec(future.resolver());
                result = future.wait();
                if (assign_to) {
                  context[assign_to] = result;
                }
              }
            } catch (_error) {
              e = _error;
              return callback(prettyErrorMessage(e, filename, cmd, true));
            }
            return callback(null, result);
          }).run();
        },
        writer: function(object) {
          return util.inspect(object, {
            colors: true,
            depth: _this.inspect_depth
          });
        }
      });
      repl.on('exit', function() {
        return process.exit(0);
      });
      addMultilineHandler(repl);
      if (process.env.HOME) {
        historyFile = path.join(process.env.HOME, '.cormo_history');
      }
      if (historyFile) {
        addHistory(repl, historyFile, 10240);
      }
      addArgCompleter(repl);
      return this._setupContext(repl.context);
    };

    CommandConsole.prototype._setupContext = function(context) {
      var connection, model, modelClass, _ref;

      context.Connection = Connection;
      context.Model = Model;
      context.connection = connection = Connection.defaultConnection;
      if (connection) {
        _ref = connection.models;
        for (model in _ref) {
          modelClass = _ref[model];
          context[model] = modelClass;
        }
      }
      return connection.applySchemas();
    };

    return CommandConsole;

  })();

  module.exports = CommandConsole;

}).call(this);
