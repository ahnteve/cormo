<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CORMO - adapters/sqlite3.ts</title><script>if (location.protocol.match(/^http/) && location.pathname.match('\.html') === null && location.pathname.slice(-1) !== '/') {
  location.href = location.href + '/';
}</script><link href="../bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]><script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script><script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]--><link href="../google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><nav class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#top-navigation-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><div class="collapse navbar-collapse" id="top-navigation-collapse"><ul class="nav navbar-nav"><li><a href="../index.html">Home</a></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Guides <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../guides/Aggregation.html">Aggregation</a></li><li><a href="../guides/Association.html">Association</a></li><li><a href="../guides/Callback.html">Callback</a></li><li><a href="../guides/Constraint.html">Constraint</a></li><li><a href="../guides/CreateRecords.html">Create records</a></li><li><a href="../guides/DefineModels.html">Define models</a></li><li><a href="../guides/Geospatial.html">Geospatial</a></li><li><a href="../guides/Miscellaneous.html">Miscellaneous</a></li><li><a href="../guides/Query.html">Query</a></li><li><a href="../guides/Validation.html">Validation</a></li></ul></li><li><a href="../modules/index.html">Modules</a></li><li><a href="../classes/index.html">Classes</a></li><li class="dropdown active"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Files - adapters/sqlite3.ts <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../files/decorators.ts.html">decorators.ts</a></li><li><a href="../files/index.ts.html">index.ts</a></li><li><a href="../files/query.ts.html">query.ts</a></li><li><a href="../files/transaction.ts.html">transaction.ts</a></li><li><a href="../files/types.ts.html">types.ts</a></li><li><a href="../files/adapters.base.ts.html">adapters/base.ts</a></li><li><a href="../files/adapters.index.ts.html">adapters/index.ts</a></li><li><a href="../files/adapters.mongodb.ts.html">adapters/mongodb.ts</a></li><li><a href="../files/adapters.mysql.ts.html">adapters/mysql.ts</a></li><li><a href="../files/adapters.postgresql.ts.html">adapters/postgresql.ts</a></li><li><a href="../files/adapters.redis.ts.html">adapters/redis.ts</a></li><li><a href="../files/adapters.sql_base.ts.html">adapters/sql_base.ts</a></li><li><a href="../files/adapters.sqlite3.ts.html">adapters/sqlite3.ts</a></li><li><a href="../files/adapters.sqlite3_memory.ts.html">adapters/sqlite3_memory.ts</a></li><li><a href="../files/command.index.ts.html">command/index.ts</a></li><li><a href="../files/connection.index.ts.html">connection/index.ts</a></li><li><a href="../files/logger.ColorConsoleLogger.ts.html">logger/ColorConsoleLogger.ts</a></li><li><a href="../files/logger.ConsoleLogger.ts.html">logger/ConsoleLogger.ts</a></li><li><a href="../files/logger.EmptyLogger.ts.html">logger/EmptyLogger.ts</a></li><li><a href="../files/logger.ILogger.ts.html">logger/ILogger.ts</a></li><li><a href="../files/logger.index.ts.html">logger/index.ts</a></li><li><a href="../files/model.index.ts.html">model/index.ts</a></li><li><a href="../files/util.index.ts.html">util/index.ts</a></li><li><a href="../files/util.inflector.ts.html">util/inflector.ts</a></li></ul></li></ul><div class="options"><label class="checkbox"><input id="options-private" type="checkbox"> Private </label></div></div></div></nav><div class="container-fluid content"><div class="row"><div class="hidden-xs sidebar col-sm-3" data-spy="affix"><div class="cormo-sidenav"><div class="panel panel-default"><div class="panel-collapse collapse in" id="undefined_body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/decorators.ts.html">decorators.ts</a></li><li><a href="../files/index.ts.html">index.ts</a></li><li><a href="../files/query.ts.html">query.ts</a></li><li><a href="../files/transaction.ts.html">transaction.ts</a></li><li><a href="../files/types.ts.html">types.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#adapters__body">adapters/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="adapters__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/adapters.base.ts.html">base.ts</a></li><li><a href="../files/adapters.index.ts.html">index.ts</a></li><li><a href="../files/adapters.mongodb.ts.html">mongodb.ts</a></li><li><a href="../files/adapters.mysql.ts.html">mysql.ts</a></li><li><a href="../files/adapters.postgresql.ts.html">postgresql.ts</a></li><li><a href="../files/adapters.redis.ts.html">redis.ts</a></li><li><a href="../files/adapters.sql_base.ts.html">sql_base.ts</a></li><li class="active"><a href="../files/adapters.sqlite3.ts.html">sqlite3.ts</a></li><li><a href="../files/adapters.sqlite3_memory.ts.html">sqlite3_memory.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#command__body">command/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="command__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/command.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#connection__body">connection/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="connection__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/connection.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#logger__body">logger/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="logger__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/logger.ColorConsoleLogger.ts.html">ColorConsoleLogger.ts</a></li><li><a href="../files/logger.ConsoleLogger.ts.html">ConsoleLogger.ts</a></li><li><a href="../files/logger.EmptyLogger.ts.html">EmptyLogger.ts</a></li><li><a href="../files/logger.ILogger.ts.html">ILogger.ts</a></li><li><a href="../files/logger.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#model__body">model/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="model__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/model.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#util__body">util/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="util__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/util.index.ts.html">index.ts</a></li><li><a href="../files/util.inflector.ts.html">inflector.ts</a></li></ul></div></div></div></div><div class="col-sm-9 col-sm-offset-3"><section><h1>adapters/sqlite3.ts</h1></section><pre class="prettyprint">let sqlite3: any;

try {
  // tslint:disable-next-line:no-var-requires
  sqlite3 = require('sqlite3');
} catch (error) {
  //
}

export interface IAdapterSettingsSQLite3 {
  database: string;
}

import _ from 'lodash';
import stream from 'stream';
import util from 'util';
import { Connection } from '../connection';
import { IColumnPropertyInternal } from '../model';
import { IsolationLevel, Transaction } from '../transaction';
import * as types from '../types';
import { IAdapterCountOptions, IAdapterFindOptions, ISchemas } from './base';
import { SQLAdapterBase } from './sql_base';

function _typeToSQL(property: IColumnPropertyInternal) {
  if (property.array) {
    return 'TEXT';
  }
  switch (property.type_class) {
    case types.String:
      return 'TEXT';
    case types.Number:
      return 'DOUBLE';
    case types.Boolean:
      return 'TINYINT';
    case types.Integer:
      return 'INT';
    case types.Date:
      return 'REAL';
    case types.Object:
      return 'TEXT';
    case types.Text:
      return 'TEXT';
  }
}

function _propertyToSQL(property: IColumnPropertyInternal) {
  let type = _typeToSQL(property);
  if (type) {
    if (property.required) {
      type += ' NOT NULL';
    } else {
      type += ' NULL';
    }
    return type;
  }
}

function _processSaveError(error: any) {
  if (/no such table/.test(error.message)) {
    return new Error('table does not exist');
  } else if (error.code === 'SQLITE_CONSTRAINT') {
    return new Error('duplicated');
  } else {
    return SQLite3Adapter.wrapError('unknown error', error);
  }
}

// Adapter for SQLite3
// @namespace adapter
export class SQLite3Adapter extends SQLAdapterBase {
  /** @internal */
  public key_type: any = types.Integer;

  /** @internal */
  public native_integrity = true;

  /** @internal */
  protected _regexp_op = null;

  /** @internal */
  protected _false_value = '0';

  /** @internal */
  private _client: any;

  /** @internal */
  private _settings!: IAdapterSettingsSQLite3;

  // Creates a SQLite3 adapter
  /** @internal */
  constructor(connection: Connection) {
    super();
    this._connection = connection;
  }

  /** @internal */
  public async getSchemas(): Promise&lt;ISchemas&gt; {
    const tables = await this._getTables();
    const table_schemas: { [table_name: string]: any } = {};
    const all_indexes: any = {};
    for (const table of tables) {
      table_schemas[table] = await this._getSchema(table);
      all_indexes[table] = await this._getIndexes(table);
    }
    return {
      indexes: all_indexes,
      tables: table_schemas,
    };
  }

  /** @internal */
  public async createTable(model: string) {
    const model_class = this._connection.models[model];
    const table_name = model_class.table_name;
    const column_sqls: any[] = [];
    // tslint:disable-next-line:forin
    for (const column in model_class._schema) {
      const property = model_class._schema[column];
      if (property.primary_key) {
        column_sqls.push(`&quot;${property._dbname_us}&quot; INTEGER PRIMARY KEY AUTOINCREMENT`);
      } else {
        const column_sql = _propertyToSQL(property);
        if (column_sql) {
          column_sqls.push(`&quot;${property._dbname_us}&quot; ${column_sql}`);
        }
      }
    }
    for (const integrity of model_class._integrities) {
      const parenttable_name = integrity.parent &amp;&amp; integrity.parent.table_name || '';
      if (integrity.type === 'child_nullify') {
        column_sqls.push(`FOREIGN KEY (&quot;${integrity.column}&quot;) REFERENCES &quot;${parenttable_name}&quot;(id) ON DELETE SET NULL`);
      } else if (integrity.type === 'child_restrict') {
        column_sqls.push(`FOREIGN KEY (&quot;${integrity.column}&quot;) REFERENCES &quot;${parenttable_name}&quot;(id) ON DELETE RESTRICT`);
      } else if (integrity.type === 'child_delete') {
        column_sqls.push(`FOREIGN KEY (&quot;${integrity.column}&quot;) REFERENCES &quot;${parenttable_name}&quot;(id) ON DELETE CASCADE`);
      }
    }
    const sql = `CREATE TABLE &quot;${table_name}&quot; ( ${column_sqls.join(',')} )`;
    try {
      await this._client.runAsync(sql);
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
  }

  /** @internal */
  public async addColumn(model: string, column_property: any) {
    const model_class = this._connection.models[model];
    const table_name = model_class.table_name;
    const column_name = column_property._dbname_us;
    const sql = `ALTER TABLE &quot;${table_name}&quot; ADD COLUMN &quot;${column_name}&quot; ${_propertyToSQL(column_property)}`;
    try {
      await this._client.runAsync(sql);
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
  }

  /** @internal */
  public async createIndex(model: string, index: any) {
    const model_class = this._connection.models[model];
    const table_name = model_class.table_name;
    const columns = [];
    // tslint:disable-next-line:forin
    for (const column in index.columns) {
      const order = index.columns[column];
      columns.push(`&quot;${column.replace(/\./g, '_')}&quot; ${(order === -1 ? 'DESC' : 'ASC')}`);
    }
    const unique = index.options.unique ? 'UNIQUE ' : '';
    const sql = `CREATE ${unique}INDEX &quot;${index.options.name}&quot; ON &quot;${table_name}&quot; (${columns.join(',')})`;
    try {
      await this._client.runAsync(sql);
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
  }

  /** @internal */
  public async drop(model: string) {
    const table_name = this._connection.models[model].table_name;
    try {
      await this._client.runAsync(`DROP TABLE IF EXISTS &quot;${table_name}&quot;`);
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
  }

  /** @internal */
  public async create(model: string, data: any, options: { transaction?: Transaction }): Promise&lt;any&gt; {
    const table_name = this._connection.models[model].table_name;
    const values: any[] = [];
    const [fields, places] = this._buildUpdateSet(model, data, values, true);
    const sql = `INSERT INTO &quot;${table_name}&quot; (${fields}) VALUES (${places})`;
    let id;
    try {
      if (options.transaction) {
        options.transaction.checkFinished();
        id = await new Promise((resolve, reject) =&gt; {
          options.transaction!._adapter_connection.run(sql, values, function(this: any, error: any) {
            if (error) {
              reject(error);
            } else {
              resolve(this.lastID);
            }
          });
        });
      } else {
        id = await new Promise((resolve, reject) =&gt; {
          this._client.run(sql, values, function(this: any, error: any) {
            if (error) {
              reject(error);
            } else {
              resolve(this.lastID);
            }
          });
        });
      }
    } catch (error) {
      throw _processSaveError(error);
    }
    return id;
  }

  /** @internal */
  public async createBulk(model: string, data: any[], options: { transaction?: Transaction }): Promise&lt;any[]&gt; {
    const table_name = this._connection.models[model].table_name;
    const values: any[] = [];
    let fields: any;
    const places: any[] = [];
    data.forEach((item) =&gt; {
      let places_sub;
      [fields, places_sub] = this._buildUpdateSet(model, item, values, true);
      return places.push('(' + places_sub + ')');
    });
    const sql = `INSERT INTO &quot;${table_name}&quot; (${fields}) VALUES ${places.join(',')}`;
    let id: any;
    try {
      id = await new Promise((resolve, reject) =&gt; {
        this._client.run(sql, values, function(this: any, error: any) {
          if (error) {
            reject(error);
          } else {
            resolve(this.lastID);
          }
        });
      });
    } catch (error) {
      throw _processSaveError(error);
    }
    if (id) {
      id = id - data.length + 1;
      return data.map((item, i) =&gt; id + i);
    } else {
      throw new Error('unexpected result');
    }
  }

  /** @internal */
  public async update(model: string, data: any, options: { transaction?: Transaction }) {
    const table_name = this._connection.models[model].table_name;
    const values: any[] = [];
    const [fields] = this._buildUpdateSet(model, data, values);
    values.push(data.id);
    const sql = `UPDATE &quot;${table_name}&quot; SET ${fields} WHERE id=?`;
    try {
      await this._client.runAsync(sql, values);
    } catch (error) {
      throw _processSaveError(error);
    }
  }

  /** @internal */
  public async updatePartial(
    model: string, data: any, conditions: any,
    options: { transaction?: Transaction },
  ): Promise&lt;number&gt; {
    const table_name = this._connection.models[model].table_name;
    const values: any[] = [];
    const [fields] = this._buildPartialUpdateSet(model, data, values);
    let sql = `UPDATE &quot;${table_name}&quot; SET ${fields}`;
    if (conditions.length &gt; 0) {
      sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, values);
    }
    try {
      return await new Promise&lt;number&gt;((resolve, reject) =&gt; {
        this._client.run(sql, values, function(this: any, error: any) {
          if (error) {
            reject(error);
          } else {
            resolve(this.changes);
          }
        });
      });
    } catch (error) {
      throw _processSaveError(error);
    }
  }

  /** @internal */
  public async findById(
    model: string, id: any,
    options: { select?: string[], explain?: boolean, transaction?: Transaction },
  ): Promise&lt;any&gt; {
    const select = this._buildSelect(this._connection.models[model], options.select);
    const table_name = this._connection.models[model].table_name;
    const sql = `SELECT ${select} FROM &quot;${table_name}&quot; WHERE id=? LIMIT 1`;
    if (options.explain) {
      return await this._client.allAsync(`EXPLAIN QUERY PLAN ${sql}`, id);
    }
    let result;
    try {
      result = (await this._client.allAsync(sql, id));
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
    if (result &amp;&amp; result.length === 1) {
      return this._convertToModelInstance(model, result[0], options);
    } else if (result &amp;&amp; result.length &gt; 1) {
      throw new Error('unknown error');
    } else {
      throw new Error('not found');
    }
  }

  /** @internal */
  public async find(model: string, conditions: any, options: IAdapterFindOptions): Promise&lt;any&gt; {
    const [sql, params] = this._buildSqlForFind(model, conditions, options);
    if (options.explain) {
      return await this._client.allAsync(`EXPLAIN QUERY PLAN ${sql}`, params);
    }
    let result;
    try {
      result = (await this._client.allAsync(sql, params));
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
    if (options.group_fields) {
      return result.map((record: any) =&gt; {
        return this._convertToGroupInstance(model, record, options.group_by, options.group_fields);
      });
    } else {
      return result.map((record: any) =&gt; {
        return this._convertToModelInstance(model, record, options);
      });
    }
  }

  /** @internal */
  public stream(model: any, conditions: any, options: IAdapterFindOptions): stream.Readable {
    let sql;
    let params;
    try {
      [sql, params] = this._buildSqlForFind(model, conditions, options);
    } catch (error) {
      const r = new stream.Readable({ objectMode: true });
      r._read = () =&gt; r.emit('error', error);
      return r;
    }
    const readable = new stream.Readable({ objectMode: true });
    readable._read = () =&gt; { /**/ };
    this._client.each(sql, params, (error: any, record: any) =&gt; {
      if (error) {
        readable.emit('error', error);
        return;
      }
      readable.push(this._convertToModelInstance(model, record, options));
    }, () =&gt; {
      readable.push(null);
    });
    return readable;
  }

  /** @internal */
  public async count(model: string, conditions: any, options: IAdapterCountOptions): Promise&lt;number&gt; {
    const params: any = [];
    const table_name = this._connection.models[model].table_name;
    let sql = `SELECT COUNT(*) AS count FROM &quot;${table_name}&quot;`;
    if (conditions.length &gt; 0) {
      sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
    }
    if (options.group_by) {
      sql += ' GROUP BY ' + options.group_by.join(',');
      if (options.conditions_of_group.length &gt; 0) {
        sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
      }
      sql = `SELECT COUNT(*) AS count FROM (${sql})`;
    }
    let result;
    try {
      result = await this._client.allAsync(sql, params);
    } catch (error) {
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
    if (result &amp;&amp; result.length !== 1) {
      throw new Error('unknown error');
    }
    return Number(result[0].count);
  }

  /** @internal */
  public async delete(model: string, conditions: any, options: { transaction?: Transaction }): Promise&lt;number&gt; {
    const params: any = [];
    const table_name = this._connection.models[model].table_name;
    let sql = `DELETE FROM &quot;${table_name}&quot;`;
    if (conditions.length &gt; 0) {
      sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
    }
    try {
      return await new Promise&lt;number&gt;((resolve, reject) =&gt; {
        this._client.run(sql, params, function(this: any, error: any) {
          if (error) {
            reject(error);
          } else {
            resolve(this.changes);
          }
        });
      });
    } catch (error) {
      if (error.code === 'SQLITE_CONSTRAINT') {
        throw new Error('rejected');
      }
      throw SQLite3Adapter.wrapError('unknown error', error);
    }
  }

  /**
   * Connects to the database
   * @internal
   */
  public async connect(settings: IAdapterSettingsSQLite3) {
    try {
      this._settings = settings;
      this._client = await this._getClient();
    } catch (error) {
      throw SQLite3Adapter.wrapError('failed to open', error);
    }
    await this._client.runAsync('PRAGMA foreign_keys=ON');
  }

  /** @internal */
  public close() {
    if (this._client) {
      this._client.close();
    }
    this._client = null;
  }

  /** @internal */
  public async getConnection(): Promise&lt;any&gt; {
    const adapter_connection = await this._getClient();
    return adapter_connection;
  }

  /** @internal */
  public async releaseConnection(adapter_connection: any): Promise&lt;void&gt; {
    adapter_connection.close();
  }

  /** @internal */
  public async startTransaction(adapter_connection: any, isolation_level?: IsolationLevel): Promise&lt;void&gt; {
    await adapter_connection.allAsync('BEGIN TRANSACTION');
  }

  /** @internal */
  public async commitTransaction(adapter_connection: any): Promise&lt;void&gt; {
    await adapter_connection.allAsync('COMMIT');
  }

  /** @internal */
  public async rollbackTransaction(adapter_connection: any): Promise&lt;void&gt; {
    await adapter_connection.allAsync('ROLLBACK');
  }

  /**
   * Exposes sqlite3 module's run method
   */
  public run(sql: string, ...params: any[]) {
    return this._client.run.apply(this._client, arguments);
  }

  /**
   * Exposes sqlite3 module's all method
   */
  public all(sql: string, ...params: any[]) {
    return this._client.all.apply(this._client, arguments);
  }

  /** @internal */
  protected valueToModel(value: any, property: any) {
    if (property.type_class === types.Object || property.array) {
      try {
        return JSON.parse(value);
      } catch (error1) {
        return null;
      }
    } else if (property.type_class === types.Date) {
      return new Date(value);
    } else if (property.type_class === types.Boolean) {
      return value !== 0;
    } else {
      return value;
    }
  }

  /** @internal */
  protected _getModelID(data: any) {
    if (!data.id) {
      return null;
    }
    return Number(data.id);
  }

  /** @internal */
  private async _getClient() {
    return await new Promise((resolve, reject) =&gt; {
      const client = new sqlite3.Database(this._settings.database, (error: any) =&gt; {
        if (error) {
          reject(error);
          return;
        }
        client.allAsync = util.promisify(client.all);
        client.runAsync = util.promisify(client.run);
        resolve(client);
      });
    });
  }

  /** @internal */
  private async _getTables() {
    const query = `SELECT name FROM sqlite_master
      WHERE type='table' and name!='sqlite_sequence'`;
    let tables = await this._client.allAsync(query);
    tables = tables.map((table: any) =&gt; table.name);
    return tables;
  }

  /** @internal */
  private async _getSchema(table: string): Promise&lt;any&gt; {
    const columns = (await this._client.allAsync(`PRAGMA table_info(\`${table}\`)`));
    const schema: any = {};
    for (const column of columns) {
      const type = /^varchar\((\d*)\)/i.test(column.type) ? new types.String(Number(RegExp.$1))
        : /^double/i.test(column.type) ? new types.Number()
          : /^tinyint/i.test(column.type) ? new types.Boolean()
            : /^int/i.test(column.type) ? new types.Integer()
              : /^real/i.test(column.type) ? new types.Date()
                : /^text/i.test(column.type) ? new types.Object() : undefined;
      schema[column.name] = {
        required: column.notnull === 1,
        type,
      };
    }
    return schema;
  }

  /** @internal */
  private async _getIndexes(table: string): Promise&lt;any&gt; {
    const rows = await this._client.allAsync(`PRAGMA index_list(\`${table}\`)`);
    const indexes: any = {};
    for (const row of rows) {
      if (!indexes[row.name]) {
        indexes[row.name] = {};
      }
      const columns = await this._client.allAsync(`PRAGMA index_info(\`${row.name}\`)`);
      for (const column of columns) {
        indexes[row.name][column.name] = 1;
      }
    }
    return indexes;
  }

  /** @internal */
  private _buildUpdateSetOfColumn(
    property: any, data: any, values: any, fields: any[], places: any[], insert: boolean = false,
  ) {
    const dbname = property._dbname_us;
    const value = data[dbname];
    if (value &amp;&amp; value.$inc != null) {
      values.push(value.$inc);
      fields.push(`&quot;${dbname}&quot;=&quot;${dbname}&quot;+?`);
    } else {
      if (property.type_class === types.Date) {
        values.push(value &amp;&amp; value.getTime());
      } else {
        values.push(value);
      }
      if (insert) {
        fields.push(`&quot;${dbname}&quot;`);
        places.push('?');
      } else {
        fields.push(`&quot;${dbname}&quot;=?`);
      }
    }
  }

  /** @internal */
  private _buildUpdateSet(model: string, data: any, values: any, insert: boolean = false) {
    const schema = this._connection.models[model]._schema;
    const fields: any[] = [];
    const places: any[] = [];
    // tslint:disable-next-line:forin
    for (const column in schema) {
      const property = schema[column];
      if (property.primary_key) {
        continue;
      }
      this._buildUpdateSetOfColumn(property, data, values, fields, places, insert);
    }
    return [fields.join(','), places.join(',')];
  }

  /** @internal */
  private _buildPartialUpdateSet(model: string, data: any, values: any[]) {
    const schema = this._connection.models[model]._schema;
    const fields: any[] = [];
    const places: any[] = [];
    // tslint:disable-next-line:forin
    for (const column in data) {
      const value = data[column];
      const property = _.find(schema, (item) =&gt; item._dbname_us === column);
      if (!property || property.primary_key) {
        continue;
      }
      this._buildUpdateSetOfColumn(property, data, values, fields, places);
    }
    return [fields.join(','), places.join(',')];
  }

  /** @internal */
  private _buildSqlForFind(model: any, conditions: any, options: any) {
    let select;
    if (options.group_by || options.group_fields) {
      select = this._buildGroupFields(options.group_by, options.group_fields);
    } else {
      select = this._buildSelect(this._connection.models[model], options.select);
    }
    const table_name = this._connection.models[model].table_name;
    const params: any[] = [];
    let sql = `SELECT ${select} FROM &quot;${table_name}&quot;`;
    if (conditions.length &gt; 0) {
      sql += ' WHERE ' + this._buildWhere(this._connection.models[model]._schema, conditions, params);
    }
    if (options.group_by) {
      sql += ' GROUP BY ' + options.group_by.join(',');
    }
    if (options.conditions_of_group.length &gt; 0) {
      sql += ' HAVING ' + this._buildWhere(options.group_fields, options.conditions_of_group, params);
    }
    if (options &amp;&amp; options.orders.length &gt; 0) {
      const model_class = this._connection.models[model];
      const schema = model_class._schema;
      const orders = options.orders.map((order: any) =&gt; {
        let column;
        if (order[0] === '-') {
          column = order.slice(1);
          order = 'DESC';
        } else {
          column = order;
          order = 'ASC';
        }
        column = schema[column] &amp;&amp; schema[column]._dbname_us || column;
        return `&quot;${column}&quot; ${order}`;
      });
      sql += ' ORDER BY ' + orders.join(',');
    }
    if (options &amp;&amp; options.limit) {
      sql += ' LIMIT ' + options.limit;
      if (options &amp;&amp; options.skip) {
        sql += ' OFFSET ' + options.skip;
      }
    } else if (options &amp;&amp; options.skip) {
      sql += ' LIMIT 2147483647 OFFSET ' + options.skip;
    }
    return [sql, params];
  }
}

export function createAdapter(connection: Connection) {
  if (!sqlite3) {
    console.log('Install sqlite3 module to use this adapter');
    process.exit(1);
  }
  return new SQLite3Adapter(connection);
}</pre></div></div></div><script src="http://code.jquery.com/jquery-1.11.0.min.js"></script><script src="../bootstrap-3.2.0-dist/js/bootstrap.min.js"></script><script src="../google-code-prettify/prettify.js"></script><script src="../script.js"></script><script src="../group-examples.js"></script><a href="https://github.com/croquiscom/cormo"><img class="github-ribbon" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a></body></html>