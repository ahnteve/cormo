<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>CORMO - query.ts</title><script>if (location.protocol.match(/^http/) && location.pathname.match('\.html') === null && location.pathname.slice(-1) !== '/') {
  location.href = location.href + '/';
}</script><link href="../bootstrap-3.2.0-dist/css/bootstrap.min.css" rel="stylesheet" type="text/css"><!--[if lt IE 9]><script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script><script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]--><link href="../google-code-prettify/prettify.css" rel="stylesheet" type="text/css"><link href="../style.css" rel="stylesheet" type="text/css"></head><body data-spy="scroll" data-target=".sidebar"><nav class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#top-navigation-collapse"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><div class="collapse navbar-collapse" id="top-navigation-collapse"><ul class="nav navbar-nav"><li><a href="../index.html">Home</a></li><li class="dropdown"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Guides <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../guides/Aggregation.html">Aggregation</a></li><li><a href="../guides/Association.html">Association</a></li><li><a href="../guides/Callback.html">Callback</a></li><li><a href="../guides/Constraint.html">Constraint</a></li><li><a href="../guides/CreateRecords.html">Create records</a></li><li><a href="../guides/DefineModels.html">Define models</a></li><li><a href="../guides/Geospatial.html">Geospatial</a></li><li><a href="../guides/Miscellaneous.html">Miscellaneous</a></li><li><a href="../guides/Query.html">Query</a></li><li><a href="../guides/Validation.html">Validation</a></li></ul></li><li><a href="../modules/index.html">Modules</a></li><li><a href="../classes/index.html">Classes</a></li><li class="dropdown active"><a class="dropdown-toggle" data-toggle="dropdown" href="#">Files - query.ts <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="../files/decorators.ts.html">decorators.ts</a></li><li><a href="../files/index.ts.html">index.ts</a></li><li><a href="../files/query.ts.html">query.ts</a></li><li><a href="../files/types.ts.html">types.ts</a></li><li><a href="../files/adapters.base.ts.html">adapters/base.ts</a></li><li><a href="../files/adapters.mongodb.ts.html">adapters/mongodb.ts</a></li><li><a href="../files/adapters.mysql.ts.html">adapters/mysql.ts</a></li><li><a href="../files/adapters.postgresql.ts.html">adapters/postgresql.ts</a></li><li><a href="../files/adapters.redis.ts.html">adapters/redis.ts</a></li><li><a href="../files/adapters.sql_base.ts.html">adapters/sql_base.ts</a></li><li><a href="../files/adapters.sqlite3.ts.html">adapters/sqlite3.ts</a></li><li><a href="../files/adapters.sqlite3_memory.ts.html">adapters/sqlite3_memory.ts</a></li><li><a href="../files/command.index.ts.html">command/index.ts</a></li><li><a href="../files/connection.index.ts.html">connection/index.ts</a></li><li><a href="../files/model.index.ts.html">model/index.ts</a></li><li><a href="../files/util.index.ts.html">util/index.ts</a></li><li><a href="../files/util.inflector.ts.html">util/inflector.ts</a></li></ul></li></ul><div class="options"><label class="checkbox"><input id="options-private" type="checkbox"> Private </label></div></div></div></nav><div class="container-fluid content"><div class="row"><div class="hidden-xs sidebar col-sm-3" data-spy="affix"><div class="cormo-sidenav"><div class="panel panel-default"><div class="panel-collapse collapse in" id="undefined_body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/decorators.ts.html">decorators.ts</a></li><li><a href="../files/index.ts.html">index.ts</a></li><li class="active"><a href="../files/query.ts.html">query.ts</a></li><li><a href="../files/types.ts.html">types.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#adapters__body">adapters/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="adapters__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/adapters.base.ts.html">base.ts</a></li><li><a href="../files/adapters.mongodb.ts.html">mongodb.ts</a></li><li><a href="../files/adapters.mysql.ts.html">mysql.ts</a></li><li><a href="../files/adapters.postgresql.ts.html">postgresql.ts</a></li><li><a href="../files/adapters.redis.ts.html">redis.ts</a></li><li><a href="../files/adapters.sql_base.ts.html">sql_base.ts</a></li><li><a href="../files/adapters.sqlite3.ts.html">sqlite3.ts</a></li><li><a href="../files/adapters.sqlite3_memory.ts.html">sqlite3_memory.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#command__body">command/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="command__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/command.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#connection__body">connection/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="connection__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/connection.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#model__body">model/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="model__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/model.index.ts.html">index.ts</a></li></ul></div></div><div class="panel panel-default"><div class="panel-heading" data-toggle="collapse" data-target="#util__body">util/<span class="pull-right glyphicon"></span></div><div class="panel-collapse collapse in" id="util__body"><ul class="nav nav-pills nav-stacked"><li><a href="../files/util.index.ts.html">index.ts</a></li><li><a href="../files/util.inflector.ts.html">inflector.ts</a></li></ul></div></div></div></div><div class="col-sm-9 col-sm-offset-3"><section><h1>query.ts</h1></section><pre class="prettyprint">import * as _ from 'lodash';
import * as stream from 'stream';

import { AdapterBase } from './adapters/base';
import { Connection } from './connection';
import { BaseModel, ModelColumnNamesWithId } from './model';
import { RecordID } from './types';

interface IQueryOptions {
  conditions_of_group: any[];
  lean: boolean;
  orders: any[];
  near?: any;
  select_columns?: string[];
  select_single: boolean;
  select?: string[];
  select_raw?: string[];
  group_fields?: any;
  group_by?: any;
  limit?: number;
  skip?: number;
  one?: boolean;
  explain?: boolean;
  cache?: {
    key: string,
    ttl: number,
    refresh?: boolean,
  };
}

export interface IQuerySingle&lt;M extends BaseModel, T = M&gt; extends PromiseLike&lt;T&gt; {
  find(id: RecordID): IQuerySingle&lt;M, T&gt;;
  find(id: RecordID[]): IQueryArray&lt;M, T&gt;;
  findPreserve(id: RecordID[]): IQueryArray&lt;M, T&gt;;
  near(target: object): IQuerySingle&lt;M, T&gt;;
  where(condition?: object): IQuerySingle&lt;M, T&gt;;
  select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns: K[]): IQuerySingle&lt;M, Pick&lt;M, K&gt;&gt;;
  select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns?: string): IQuerySingle&lt;M, Pick&lt;M, K&gt;&gt;;
  selectSingle&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(column: K): IQuerySingle&lt;M, M[K]&gt;;
  order(orders: string): IQuerySingle&lt;M, T&gt;;
  group&lt;G extends ModelColumnNamesWithId&lt;M&gt;, F&gt;(group_by: G | G[], fields?: F):
    IQuerySingle&lt;M, { [field in keyof F]: number } &amp; Pick&lt;M, G&gt;&gt;;
  group&lt;F&gt;(group_by: null, fields?: F):
    IQuerySingle&lt;M, { [field in keyof F]: number }&gt;;
  group&lt;U&gt;(group_by: string | null, fields?: object): IQuerySingle&lt;M, U&gt;;
  one(): IQuerySingle&lt;M, T&gt;;
  limit(limit?: number): IQuerySingle&lt;M, T&gt;;
  skip(skip?: number): IQuerySingle&lt;M, T&gt;;
  lean(lean?: boolean): IQuerySingle&lt;M, T&gt;;
  if(condition: boolean): IQuerySingle&lt;M, T&gt;;
  endif(): IQuerySingle&lt;M, T&gt;;
  cache(options: IQueryOptions['cache']): IQuerySingle&lt;M, T&gt;;
  include(column: string, select?: string): IQuerySingle&lt;M, T&gt;;

  exec(options?: any): PromiseLike&lt;T&gt;;
  stream(): stream.Readable;
  explain(): PromiseLike&lt;any&gt;;
  count(): PromiseLike&lt;number&gt;;
  update(updates: object): PromiseLike&lt;number&gt;;
  upsert(updates: object): PromiseLike&lt;void&gt;;
  delete(options?: any): PromiseLike&lt;number&gt;;
}

export interface IQueryArray&lt;M extends BaseModel, T = M&gt; extends PromiseLike&lt;T[]&gt; {
  find(id: RecordID): IQuerySingle&lt;M, T&gt;;
  find(id: RecordID[]): IQueryArray&lt;M, T&gt;;
  findPreserve(id: RecordID[]): IQueryArray&lt;M, T&gt;;
  near(target: object): IQueryArray&lt;M, T&gt;;
  where(condition?: object): IQueryArray&lt;M, T&gt;;
  select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns: K[]): IQueryArray&lt;M, Pick&lt;M, K&gt;&gt;;
  select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns?: string): IQueryArray&lt;M, Pick&lt;M, K&gt;&gt;;
  selectSingle&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(column: K): IQueryArray&lt;M, M[K]&gt;;
  order(orders: string): IQueryArray&lt;M, T&gt;;
  group&lt;G extends ModelColumnNamesWithId&lt;M&gt;, F&gt;(group_by: G | G[], fields?: F):
    IQueryArray&lt;M, { [field in keyof F]: number } &amp; Pick&lt;M, G&gt;&gt;;
  group&lt;F&gt;(group_by: null, fields?: F):
    IQueryArray&lt;M, { [field in keyof F]: number }&gt;;
  group&lt;U&gt;(group_by: string | null, fields?: object): IQueryArray&lt;M, U&gt;;
  one(): IQuerySingle&lt;M, T&gt;;
  limit(limit?: number): IQueryArray&lt;M, T&gt;;
  skip(skip?: number): IQueryArray&lt;M, T&gt;;
  lean(lean?: boolean): IQueryArray&lt;M, T&gt;;
  if(condition: boolean): IQueryArray&lt;M, T&gt;;
  endif(): IQueryArray&lt;M, T&gt;;
  cache(options: IQueryOptions['cache']): IQueryArray&lt;M, T&gt;;
  include(column: string, select?: string): IQueryArray&lt;M, T&gt;;

  exec(options?: any): PromiseLike&lt;T[]&gt;;
  stream(): stream.Readable;
  explain(): PromiseLike&lt;any&gt;;
  count(): PromiseLike&lt;number&gt;;
  update(updates: object): PromiseLike&lt;number&gt;;
  upsert(updates: object): PromiseLike&lt;void&gt;;
  delete(options?: any): PromiseLike&lt;number&gt;;
}

type IQuery&lt;M extends BaseModel, T = M&gt; = IQuerySingle&lt;M, T&gt; | IQueryArray&lt;M, T&gt;;

/**
 * Collects conditions to query
 */
class Query&lt;M extends BaseModel, T = M&gt; implements IQuerySingle&lt;M, T&gt;, IQueryArray&lt;M, T&gt; {
  private _model: typeof BaseModel;
  private _name: string;
  private _connection: Connection;
  private _adapter: AdapterBase;
  private _ifs: boolean[];
  private _current_if: boolean;
  private _options: IQueryOptions;
  private _conditions: any[];
  private _includes: any[];
  private _id: any;
  private _find_single_id = false;
  private _preserve_order_ids?: any[];

  /**
   * Creates a query instance
   */
  constructor(model: typeof BaseModel) {
    this._model = model;
    this._name = model._name;
    this._connection = model._connection;
    this._adapter = model._connection._adapter;
    this._ifs = [];
    this._current_if = true;
    this._conditions = [];
    this._includes = [];
    this._options = {
      conditions_of_group: [],
      lean: model.lean_query,
      orders: [],
      select_single: false,
    };
  }

  /**
   * Finds a record by id
   */
  public find(id: RecordID): IQuerySingle&lt;M, T&gt;;
  public find(id: RecordID[]): IQueryArray&lt;M, T&gt;;
  public find(id: RecordID | RecordID[]): IQuery&lt;M, T&gt; {
    if (!this._current_if) {
      return this;
    }
    if (Array.isArray(id)) {
      this._id = _.uniq(id);
      this._find_single_id = false;
    } else {
      this._id = id;
      this._find_single_id = true;
    }
    return this;
  }

  /**
   * Finds records by ids while preserving order.
   */
  public findPreserve(ids: RecordID[]): IQueryArray&lt;M, T&gt; {
    if (!this._current_if) {
      return this;
    }
    this._id = _.uniq(ids);
    this._find_single_id = false;
    this._preserve_order_ids = ids;
    return this;
  }

  /**
   * Finds records near target
   */
  public near(target: object): this {
    if (!this._current_if) {
      return this;
    }
    this._options.near = target;
    return this;
  }

  /**
   * Finds records by condition
   */
  public where(condition?: object): this {
    if (!this._current_if) {
      return this;
    }
    if (Array.isArray(condition)) {
      condition.forEach((cond) =&gt; {
        this._addCondition(cond);
      });
    } else if (condition != null) {
      this._addCondition(condition);
    }
    return this;
  }

  /**
   * Selects columns for result
   */
  public select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns?: string | string[]): IQuerySingle&lt;M, Pick&lt;M, K&gt;&gt;;
  public select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns?: string | string[]): IQueryArray&lt;M, Pick&lt;M, K&gt;&gt;;
  public select&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(columns?: string | string[]): IQuery&lt;M, Pick&lt;M, K&gt;&gt; {
    if (!this._current_if) {
      return this as any;
    }
    this._options.select_columns = undefined;
    this._options.select_single = false;
    if (columns != null) {
      if (typeof columns === 'string') {
        columns = columns.split(/\s+/);
        columns.push('id');
      }
      if (columns.length &gt; 0) {
        this._options.select_columns = columns;
      }
    }
    return this as any;
  }

  public selectSingle&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(column: K): IQuerySingle&lt;M, M[K]&gt;;
  public selectSingle&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(column: K): IQueryArray&lt;M, M[K]&gt;;
  public selectSingle&lt;K extends ModelColumnNamesWithId&lt;M&gt;&gt;(column: string): IQuery&lt;M, M[K]&gt; {
    if (!this._current_if) {
      return this as any;
    }
    this._options.select_columns = [column];
    this._options.select_single = true;
    return this as any;
  }

  /**
   * Specifies orders of result
   */
  public order(orders: string): this {
    if (!this._current_if) {
      return this;
    }
    if (typeof orders === 'string') {
      const avaliable_columns = ['id'];
      avaliable_columns.push(...Object.keys(this._model._schema));
      if (this._options.group_fields) {
        avaliable_columns.push(...Object.keys(this._options.group_fields));
      }
      orders.split(/\s+/).forEach((order) =&gt; {
        let asc = true;
        if (order[0] === '-') {
          asc = false;
          order = order.slice(1);
        }
        if (avaliable_columns.indexOf(order) &gt;= 0) {
          this._options.orders.push(asc ? order : '-' + order);
        }
      });
    }
    return this;
  }

  /**
   * Groups result records
   */
  public group&lt;U&gt;(group_by: string | string[] | null, fields?: object): IQuerySingle&lt;M, U&gt;;
  public group&lt;U&gt;(group_by: string | string[] | null, fields?: object): IQueryArray&lt;M, U&gt;;
  public group&lt;U&gt;(group_by: string | string[] | null, fields?: object): IQuery&lt;M, U&gt; {
    if (!this._current_if) {
      return this as any;
    }
    this._options.group_by = null;
    const schema_columns = Object.keys(this._model._schema);
    if (group_by) {
      if (typeof group_by === 'string') {
        group_by = group_by.split(/\s+/);
      }
      this._options.group_by = group_by.filter((column) =&gt; {
        return schema_columns.indexOf(column) &gt;= 0;
      });
    }
    this._options.group_fields = fields;
    return this as any;
  }

  /**
   * Returns only one record (or null if does not exists).
   *
   * This is different from limit(1). limit(1) returns array of length 1 while this returns an instance.
   */
  public one(): this {
    if (!this._current_if) {
      return this;
    }
    this._options.limit = 1;
    this._options.one = true;
    return this;
  }

  /**
   * Sets limit of query
   */
  public limit(limit: number): this {
    if (!this._current_if) {
      return this;
    }
    this._options.limit = limit;
    return this;
  }

  /**
   * Sets skip of query
   */
  public skip(skip: number): this {
    if (!this._current_if) {
      return this;
    }
    this._options.skip = skip;
    return this;
  }

  /**
   * Returns raw instances instead of model instances
   * @see Query::exec
   */
  public lean(lean = true): this {
    if (!this._current_if) {
      return this;
    }
    this._options.lean = lean;
    return this;
  }

  /**
   * Makes a part of the query chain conditional
   * @see Query::endif
   */
  public if(condition: boolean): this {
    this._ifs.push(condition);
    this._current_if = this._current_if &amp;&amp; condition;
    return this;
  }

  /**
   * Ends last if
   * @chainable
   * @see Query::if
   */
  public endif() {
    this._ifs.pop();
    this._current_if = true;
    for (const condition of this._ifs) {
      this._current_if = this._current_if &amp;&amp; condition;
    }
    return this;
  }

  /**
   * Cache result.
   *
   * If cache of key exists, actual query does not performed.
   * If cache does not exist, query result will be saved in cache.
   *
   * Redis is used to cache.
   */
  public cache(options: IQueryOptions['cache']): this {
    if (!this._current_if) {
      return this;
    }
    this._options.cache = options;
    return this;
  }

  /**
   * Returns associated objects also
   */
  public include(column: any, select: any): this {
    if (!this._current_if) {
      return this;
    }
    this._includes.push({ column, select });
    return this;
  }

  /**
   * Executes the query
   * @see AdapterBase::findById
   * @see AdapterBase::find
   */
  public async exec(options?: any) {
    await this._model._checkReady();
    if (this._options.cache &amp;&amp; this._options.cache.key) {
      try {
        // try cache
        return await this._model._loadFromCache(this._options.cache.key, this._options.cache.refresh);
      } catch (error) {
        // no cache, execute query
        const records = await this._execAndInclude(options);
        // save result to cache
        await this._model._saveToCache(this._options.cache.key, this._options.cache.ttl, records);
        return records;
      }
    } else {
      return await this._execAndInclude(options);
    }
  }

  /**
   * Executes the query and returns a readable stream
   * @see AdapterBase::findById
   * @see AdapterBase::find
   */
  public stream(): stream.Readable {
    const transformer = new stream.Transform({ objectMode: true });
    transformer._transform = function(chunk, encoding, callback) {
      this.push(chunk);
      callback();
    };
    this._model._checkReady().then(() =&gt; {
      this._adapter.stream(this._name, this._conditions, this._options)
        .on('error', (error) =&gt; {
          transformer.emit('error', error);
        }).pipe(transformer);
    });
    return transformer;
  }

  /**
   * Explains the query
   */
  public async explain() {
    this._options.cache = undefined;
    this._options.explain = true;
    this._includes = [];
    return await this.exec({ skip_log: true });
  }

  /**
   * Executes the query as a promise (.then == .exec().then)
   */
  public then&lt;TResult1 = T, TResult2 = never&gt;(
    onfulfilled?: ((value: T) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) |
      ((value: T[]) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | undefined | null,
    onrejected?: ((reason: any) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | undefined | null,
  ): PromiseLike&lt;TResult1 | TResult2&gt;;
  public then&lt;TResult1 = T, TResult2 = never&gt;(
    onfulfilled?: ((value: T) =&gt; TResult1 | PromiseLike&lt;TResult1&gt;) | undefined | null,
    onrejected?: ((reason: any) =&gt; TResult2 | PromiseLike&lt;TResult2&gt;) | undefined | null,
  ): PromiseLike&lt;TResult1 | TResult2&gt; {
    return this.exec().then(onfulfilled, onrejected);
  }

  /**
   * Executes the query as a count operation
   * @see AdapterBase::count
   */
  public async count(): Promise&lt;number&gt; {
    await this._model._checkReady();
    if (this._id || this._find_single_id) {
      this._conditions.push({ id: this._id });
      delete this._id;
    }
    return await this._adapter.count(this._name, this._conditions, this._options);
  }

  /**
   * Executes the query as a update operation
   * @see AdapterBase::update
   */
  public async update(updates: any): Promise&lt;number&gt; {
    await this._model._checkReady();
    const errors: any[] = [];
    const data = {};
    this._validateAndBuildSaveData(errors, data, updates, '', updates);
    if (errors.length &gt; 0) {
      throw new Error(errors.join(','));
    }
    if (this._id || this._find_single_id) {
      this._conditions.push({ id: this._id });
      delete this._id;
    }
    this._connection.log(this._name, 'update', { data, conditions: this._conditions, options: this._options });
    return await this._adapter.updatePartial(this._name, data, this._conditions, this._options);
  }

  /**
   * Executes the query as an insert or update operation
   * @see AdapterBase::upsert
   */
  public async upsert(updates: any): Promise&lt;void&gt; {
    await this._model._checkReady();
    const errors: any[] = [];
    const data = {};
    this._validateAndBuildSaveData(errors, data, updates, '', updates);
    if (errors.length &gt; 0) {
      throw new Error(errors.join(','));
    }
    if (this._id || this._find_single_id) {
      this._conditions.push({ id: this._id });
      delete this._id;
    }
    this._connection.log(this._name, 'upsert', { data, conditions: this._conditions, options: this._options });
    return await this._adapter.upsert(this._name, data, this._conditions, this._options);
  }

  /**
   * Executes the query as a delete operation
   * @see AdapterBase::delete
   */
  public async delete(options?: any): Promise&lt;number&gt; {
    await this._model._checkReady();
    if (this._id || this._find_single_id) {
      this._conditions.push({ id: this._id });
      delete this._id;
    }
    if (!(options &amp;&amp; options.skip_log)) {
      this._connection.log(this._name, 'delete', { conditions: this._conditions });
    }
    await this._doArchiveAndIntegrity(options);
    return await this._adapter.delete(this._name, this._conditions);
  }

  private async _exec(options: any) {
    if (this._find_single_id &amp;&amp; this._conditions.length === 0) {
      if (!(options &amp;&amp; options.skip_log)) {
        this._connection.log(this._name, 'find by id', { id: this._id, options: this._options });
      }
      if (!this._id) {
        throw new Error('not found');
      }
      let record;
      try {
        record = await this._adapter.findById(this._name, this._id, this._options);
      } catch (error) {
        throw new Error('not found');
      }
      if (!record) {
        throw new Error('not found');
      }
      return record;
    }
    let expected_count: number | undefined;
    if (this._id || this._find_single_id) {
      if (Array.isArray(this._id)) {
        if (this._id.length === 0) {
          return [];
        }
        this._conditions.push({ id: { $in: this._id } });
        expected_count = this._id.length;
      } else {
        this._conditions.push({ id: this._id });
        expected_count = 1;
      }
    }
    if (!(options &amp;&amp; options.skip_log)) {
      this._connection.log(this._name, 'find', { conditions: this._conditions, options: this._options });
    }
    let records = await this._adapter.find(this._name, this._conditions, this._options);
    if (expected_count != null) {
      if (records.length !== expected_count) {
        throw new Error('not found');
      }
    }
    if (this._preserve_order_ids) {
      records = this._preserve_order_ids.map((id) =&gt; {
        for (const record of records) {
          if (record.id === id) {
            return record;
          }
        }
      });
    }
    if (this._options.one) {
      if (records.length &gt; 1) {
        throw new Error('unknown error');
      }
      if (records.length === 1) {
        return records[0];
      } else {
        return null;
      }
    } else {
      return records;
    }
  }

  private async _execAndInclude(options?: any) {
    this._options.select = undefined;
    this._options.select_raw = undefined;
    if (this._options.select_columns) {
      const schema_columns = Object.keys(this._model._schema);
      const intermediate_paths = this._model._intermediate_paths;
      const select: string[] = [];
      const select_raw: string[] = [];
      this._options.select_columns.forEach((column) =&gt; {
        if (schema_columns.indexOf(column) &gt;= 0) {
          select.push(column);
          select_raw.push(column);
        } else if (intermediate_paths[column]) {
          // select all nested columns
          select_raw.push(column);
          column += '.';
          schema_columns.forEach((sc) =&gt; {
            if (sc.indexOf(column) === 0) {
              select.push(sc);
            }
          });
        }
      });
      if (select_raw.length &gt; 0) {
        this._options.select = select;
        this._options.select_raw = select_raw;
      }
    }
    const records = await this._exec(options);
    if (this._options.select_single) {
      if (Array.isArray(records)) {
        return _.map(records, this._options.select_columns![0]);
      } else {
        if (records) {
          return records[this._options.select_columns![0]];
        } else {
          return null;
        }
      }
    }
    await Promise.all(this._includes.map(async (include) =&gt; {
      await this._connection.fetchAssociated(records, include.column, include.select, {
        lean: this._options.lean,
        model: this._model,
      });
    }));
    return records;
  }

  private _validateAndBuildSaveData(errors: any, data: any, updates: any, path: any, object: any) {
    const model = this._model;
    const schema = model._schema;
    // tslint:disable-next-line:forin
    for (let column in object) {
      const property = schema[path + column];
      if (property) {
        try {
          model._validateColumn(updates, path + column, property, true);
        } catch (error) {
          errors.push(error.message);
        }
        model._buildSaveDataColumn(data, updates, path + column, property, true);
      } else if (!object[column] &amp;&amp; model._intermediate_paths[column]) {
        // set all nested columns null
        column += '.';
        const temp: any = {};
        Object.keys(schema).forEach((sc) =&gt; {
          if (sc.indexOf(column) === 0) {
            temp[sc.substr(column.length)] = null;
          }
        });
        this._validateAndBuildSaveData(errors, data, updates, path + column, temp);
      } else if (typeof object[column] === 'object') {
        this._validateAndBuildSaveData(errors, data, updates, path + column + '.', object[column]);
      }
    }
  }

  private async _doIntegrityActions(integrities: any, ids: any) {
    const promises = integrities.map(async (integrity: any) =&gt; {
      if (integrity.type === 'parent_nullify') {
        await integrity.child.update(_.zipObject([integrity.column], [null]), _.zipObject([integrity.column], [ids]));
      } else if (integrity.type === 'parent_restrict') {
        const count = (await integrity.child.count(_.zipObject([integrity.column], [ids])));
        if (count &gt; 0) {
          throw new Error('rejected');
        }
      } else if (integrity.type === 'parent_delete') {
        await integrity.child.delete(_.zipObject([integrity.column], [ids]));
      }
    });
    await Promise.all(promises);
  }

  private async _doArchiveAndIntegrity(options: any) {
    const need_archive = this._model.archive;
    const integrities = this._model._integrities.filter((integrity) =&gt; integrity.type.substr(0, 7) === 'parent_');
    const need_child_archive = integrities.some((integrity) =&gt; integrity.child.archive);
    const need_integrity = need_child_archive || (integrities.length &gt; 0 &amp;&amp; !this._adapter.native_integrity);
    if (!need_archive &amp;&amp; !need_integrity) {
      return;
    }
    // find all records to be deleted
    const query = this._model.where(this._conditions);
    if (!need_archive) { // we need only id field for integrity
      query.select('');
    }
    const records: any[] = await query.exec({ skip_log: options &amp;&amp; options.skip_log });
    if (need_archive) {
      const archive_records: any[] = records.map((record) =&gt; {
        return { model: this._name, data: record };
      });
      await this._connection.models._Archive.createBulk(archive_records);
    }
    if (!need_integrity) {
      return;
    }
    if (records.length === 0) {
      return;
    }
    const ids = records.map((record) =&gt; record.id);
    await this._doIntegrityActions(integrities, ids);
  }

  private _addCondition(condition: any) {
    if (this._options.group_fields) {
      const keys = Object.keys(condition);
      if (keys.length === 1 &amp;&amp; this._options.group_fields.hasOwnProperty(keys[0])) {
        this._options.conditions_of_group.push(condition);
      }
    } else {
      this._conditions.push(condition);
    }
  }
}

export { Query };</pre></div></div></div><script src="http://code.jquery.com/jquery-1.11.0.min.js"></script><script src="../bootstrap-3.2.0-dist/js/bootstrap.min.js"></script><script src="../google-code-prettify/prettify.js"></script><script src="../script.js"></script><script src="../group-examples.js"></script><a href="https://github.com/croquiscom/cormo"><img class="github-ribbon" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a></body></html>